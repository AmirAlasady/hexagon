│   .env
│   [
│       # .env
│       
│       # Django's main secret key
│       DJANGO_SECRET_KEY='django-insecure-m3x$8o#1ol@+fo8xbg5ldpcuck6bytc4h1*8v!=8(_wau6g8or'
│       JWT_SECRET_KEY ='jwt-secure-m3x$DFGRTJRTYNEHRETNEFDDHD43.m<?><DFGRTJYRJGc4h1*8v!=8(_wau6g8or'
│       # You can also add other environment-specific settings here
│       DJANGO_DEBUG='True'
│       DATABASE_URL='sqlite:///./db.sqlite3' # Example for database config
│       JWT_ISSUER="https://ms1.auth-service.com"
│       RABBITMQ_URL='amqp://guest:guest@localhost:5672/'
│   ]
├───MS1
│   __init__.py
│   [
│       
│   ]
│   asgi.py
│   [
│       """
│       ASGI config for MS1 project.
│       
│       It exposes the ASGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
│       """
│       
│       import os
│       
│       from django.core.asgi import get_asgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS1.settings')
│       
│       application = get_asgi_application()
│       
│   ]
│   settings.py
│   [
│       import os
│       from pathlib import Path
│       from datetime import timedelta
│       from dotenv import load_dotenv
│       
│       BASE_DIR = Path(__file__).resolve().parent.parent
│       load_dotenv(BASE_DIR / '.env')
│       
│       SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
│       JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
│       DEBUG = os.getenv('DJANGO_DEBUG', 'False').lower() in ('true', '1', 't')
│       
│       ALLOWED_HOSTS = ['*']
│       
│       INSTALLED_APPS = [
│           'django.contrib.admin',
│           'django.contrib.auth',
│           'django.contrib.contenttypes',
│           'django.contrib.sessions',
│           'django.contrib.messages',
│           'django.contrib.staticfiles',
│           # Third-party apps
│           'rest_framework',
│           'rest_framework_simplejwt',
│           # Local apps
│           'accounts',
│           'messaging',
│       ]
│       
│       MIDDLEWARE = [
│           'django.middleware.security.SecurityMiddleware',
│           'django.contrib.sessions.middleware.SessionMiddleware',
│           'django.middleware.common.CommonMiddleware',
│           'django.middleware.csrf.CsrfViewMiddleware',
│           'django.contrib.auth.middleware.AuthenticationMiddleware',
│           'django.contrib.messages.middleware.MessageMiddleware',
│           'django.middleware.clickjacking.XFrameOptionsMiddleware',
│       ]
│       
│       ROOT_URLCONF = 'MS1.urls'
│       WSGI_APPLICATION = 'MS1.wsgi.application'
│       
│       TEMPLATES = [
│           {
│               'BACKEND': 'django.template.backends.django.DjangoTemplates',
│               'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [
│                   'django.template.context_processors.debug', 'django.template.context_processors.request',
│                   'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages',
│               ],},
│           },
│       ]
│       STATIC_URL = '/static/'
│       STATIC_ROOT = BASE_DIR / 'staticfiles'
│       
│       DATABASES = {
│           'default': {
│               'ENGINE': 'django.db.backends.sqlite3',
│               'NAME': BASE_DIR / 'db.sqlite3',
│           }
│       }
│       
│       AUTH_USER_MODEL = "accounts.User"
│       
│       # Password validation
│       AUTH_PASSWORD_VALIDATORS = [
│           {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
│           {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
│           {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
│           {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
│       ]
│       
│       LANGUAGE_CODE = 'en-us'
│       TIME_ZONE = 'UTC'
│       USE_I18N = True
│       USE_TZ = True
│       DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
│       
│       # REST Framework Settings
│       REST_FRAMEWORK = {
│           "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
│           "DEFAULT_AUTHENTICATION_CLASSES": ("rest_framework_simplejwt.authentication.JWTAuthentication",),
│       }
│       
│       # Simple JWT Settings (The contract with other services)
│       SIMPLE_JWT = {
│           "ACCESS_TOKEN_LIFETIME": timedelta(minutes=1000),
│           "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
│           "ROTATE_REFRESH_TOKENS": False,
│           "BLACKLIST_AFTER_ROTATION": False,
│           "UPDATE_LAST_LOGIN": True,
│       
│           "ALGORITHM": "HS256",
│           "SIGNING_KEY": JWT_SECRET_KEY, # Use the shared secret key
│           "VERIFYING_KEY": JWT_SECRET_KEY,
│           "ISSUER": os.getenv('JWT_ISSUER'), # The claim MUST match what other services expect
│       
│           "AUTH_HEADER_TYPES": ("Bearer",),
│           "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",
│           "USER_ID_FIELD": "id",
│           "USER_ID_CLAIM": "user_id", # This claim name MUST be consistent
│           "USER_AUTHENTICATION_RULE": "rest_framework_simplejwt.authentication.default_user_authentication_rule",
│       
│           "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
│           "TOKEN_TYPE_CLAIM": "token_type",
│           "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser",
│       
│           # Custom serializer to add extra claims to the token
│           "TOKEN_OBTAIN_SERIALIZER": "accounts.serializers.CustomTokenObtainPairSerializer",
│       }
│       
│       # RabbitMQ Settings
│       RABBITMQ_URL = os.getenv('RABBITMQ_URL', 'amqp://guest:guest@localhost:5672/')
│   ]
│   urls.py
│   [
│       from django.contrib import admin
│       from django.urls import path, include
│       
│       urlpatterns = [
│           # Wrap both admin and api under the 'ms1/' prefix
│           path('ms1/', include([
│               path('admin/', admin.site.urls),
│               path('api/v1/auth/', include('accounts.api_urls')),
│           ]))
│       ]
│   ]
│   wsgi.py
│   [
│       """
│       WSGI config for MS1 project.
│       
│       It exposes the WSGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
│       """
│       
│       import os
│       
│       from django.core.wsgi import get_wsgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS1.settings')
│       
│       application = get_wsgi_application()
│       
│   ]
├───accounts
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       from .models import User
│       
│       admin.site.register(User)
│       
│       
│   ]
│   api_urls.py
│   [
│       from django.urls import path
│       from rest_framework_simplejwt.views import TokenRefreshView
│       from .api_views import (
│           UserRegistrationView,
│           CustomTokenObtainPairView,
│           CurrentUserView,
│       )
│       
│       urlpatterns = [
│           path('register/', UserRegistrationView.as_view(), name='user-register'),
│           path('token/', CustomTokenObtainPairView.as_view(), name='token-create'),
│           path('token/refresh/', TokenRefreshView.as_view(), name='token-refresh'),
│           path('me/', CurrentUserView.as_view(), name='current-user'),
│       ]
│   ]
│   api_views.py
│   [
│       from rest_framework import generics, permissions, status
│       from rest_framework.views import APIView
│       from rest_framework.response import Response
│       from django.contrib.auth import get_user_model
│       from django.db import transaction
│       from rest_framework_simplejwt.views import TokenObtainPairView
│       
│       from .serializers import (
│           UserRegistrationSerializer,
│           CurrentUserSerializer,
│           ChangePasswordSerializer,
│           CustomTokenObtainPairSerializer,
│       )
│       from messaging.models import UserSaga, UserSagaStep
│       from messaging.event_publisher import event_publisher
│       
│       User = get_user_model()
│       
│       class UserRegistrationView(generics.CreateAPIView):
│           queryset = User.objects.all()
│           permission_classes = [permissions.AllowAny]
│           serializer_class = UserRegistrationSerializer
│       
│       class CustomTokenObtainPairView(TokenObtainPairView):
│           """
│           Uses our custom serializer to include extra claims in the token.
│           """
│           serializer_class = CustomTokenObtainPairSerializer
│       
│       class CurrentUserView(APIView):
│           permission_classes = [permissions.IsAuthenticated]
│       
│           def get(self, request):
│               """Retrieve details of the currently authenticated user."""
│               serializer = CurrentUserSerializer(request.user)
│               return Response(serializer.data)
│       
│           def put(self, request):
│               """Update the current user's password."""
│               user = request.user
│               serializer = ChangePasswordSerializer(data=request.data, context={'request': request})
│               serializer.is_valid(raise_exception=True)
│               user.set_password(serializer.validated_data['new_password'])
│               user.save()
│               return Response({"detail": "Password updated successfully."}, status=status.HTTP_200_OK)
│       
│           def delete(self, request):
│               """Initiates the user deletion saga for the authenticated user."""
│               user = request.user
│       
│               if UserSaga.objects.filter(user_id=user.id, status=UserSaga.SagaStatus.IN_PROGRESS).exists():
│                   return Response({"detail": "Account deletion is already in progress."}, status=status.HTTP_409_CONFLICT)
│               
│               try:
│                   with transaction.atomic():
│                       # 1. Soft-delete the user to disable access immediately
│                       user.is_active = False
│                       user.save(update_fields=['is_active'])
│       
│                       # 2. Create the saga state tracker
│                       saga = UserSaga.objects.create(user_id=user.id)
│                       # Define which services need to confirm cleanup
│                       services_to_confirm = ['ProjectService', 'AIModelService', 'ToolService'] # Add more as your system grows
│                       for service_name in services_to_confirm:
│                           UserSagaStep.objects.create(saga=saga, service_name=service_name)
│       
│                       # 3. Publish the event. This is the point of no return for the transaction.
│                       event_publisher.publish_user_deletion_initiated(user_id=user.id)
│       
│               except Exception as e:
│                   # If event publishing fails, the transaction will be rolled back.
│                   # The user will remain active, and the saga records won't be created.
│                   print(f"CRITICAL: Failed to initiate user deletion saga for {user.id}. Error: {e}")
│                   return Response(
│                       {"error": "The account deletion process could not be started due to a system error."},
│                       status=status.HTTP_500_INTERNAL_SERVER_ERROR
│                   )
│       
│               return Response(
│                   {"message": "Your account deletion request has been received and is being processed."},
│                   status=status.HTTP_202_ACCEPTED
│               )
│   ]
│   apps.py
│   [
│       # accounts/apps.py
│       from django.apps import AppConfig
│       
│       class AccountsConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'accounts'
│       
│   ]
│   models.py
│   [
│       import uuid
│       from django.db import models
│       from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
│       
│       class UserManager(BaseUserManager):
│           def create_user(self, email, username, password=None, **extra_fields):
│               if not email:
│                   raise ValueError("The Email field must be set")
│               if not username:
│                   raise ValueError("The Username field must be set")
│       
│               email = self.normalize_email(email)
│               user = self.model(email=email, username=username, **extra_fields)
│               user.set_password(password)
│               user.save(using=self._db)
│               return user
│       
│           def create_superuser(self, email, username, password=None, **extra_fields):
│               extra_fields.setdefault('is_staff', True)
│               extra_fields.setdefault('is_superuser', True)
│       
│               if extra_fields.get("is_staff") is not True:
│                   raise ValueError("Superuser must have is_staff=True.")
│               if extra_fields.get("is_superuser") is not True:
│                   raise ValueError("Superuser must have is_superuser=True.")
│       
│               return self.create_user(email, username, password, **extra_fields)
│       
│       class User(AbstractBaseUser, PermissionsMixin):
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           email = models.EmailField(unique=True, max_length=255)
│           username = models.CharField(max_length=150, unique=True)
│           is_active = models.BooleanField(default=True, help_text="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
│           is_staff = models.BooleanField(default=False)
│           date_joined = models.DateTimeField(auto_now_add=True)
│       
│           objects = UserManager()
│       
│           USERNAME_FIELD = 'email'
│           REQUIRED_FIELDS = ['username']
│       
│           def __str__(self):
│               return self.email
│   ]
│   serializers.py
│   [
│       from rest_framework import serializers
│       from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
│       from django.contrib.auth import get_user_model
│       from django.contrib.auth.password_validation import validate_password
│       
│       User = get_user_model()
│       
│       class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
│           """
│           Customizes the JWT token claims to include extra user information.
│           This is the core of the contract with other microservices.
│           """
│           @classmethod
│           def get_token(cls, user):
│               token = super().get_token(user)
│               # Add custom claims
│               token['username'] = user.username
│               token['is_staff'] = user.is_staff
│               return token
│       
│       class UserRegistrationSerializer(serializers.ModelSerializer):
│           password = serializers.CharField(write_only=True, required=True, validators=[validate_password])
│           password2 = serializers.CharField(write_only=True, required=True)
│       
│           class Meta:
│               model = User
│               fields = ('email', 'username', 'password', 'password2')
│       
│           def validate(self, attrs):
│               if attrs['password'] != attrs['password2']:
│                   raise serializers.ValidationError({"password": "Password fields didn't match."})
│               return attrs
│       
│           def create(self, validated_data):
│               user = User.objects.create_user(
│                   email=validated_data['email'],
│                   username=validated_data['username'],
│                   password=validated_data['password']
│               )
│               return user
│       
│       class CurrentUserSerializer(serializers.ModelSerializer):
│           """Serializer for retrieving the current user's data."""
│           class Meta:
│               model = User
│               fields = ('id', 'email', 'username', 'is_active', 'date_joined')
│       
│       class ChangePasswordSerializer(serializers.Serializer):
│           current_password = serializers.CharField(required=True, write_only=True)
│           new_password = serializers.CharField(required=True, write_only=True, validators=[validate_password])
│       
│           def validate_current_password(self, value):
│               user = self.context['request'].user
│               if not user.check_password(value):
│                   raise serializers.ValidationError("Current password is not correct.")
│               return value
│   ]
│   db.sqlite3
│   [
│       [Binary file - content not shown]
│   ]
│   manage.py
│   [
│       #!/usr/bin/env python
│       """Django's command-line utility for administrative tasks."""
│       import os
│       import sys
│       
│       
│       def main():
│           """Run administrative tasks."""
│           os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS1.settings')
│           try:
│               from django.core.management import execute_from_command_line
│           except ImportError as exc:
│               raise ImportError(
│                   "Couldn't import Django. Are you sure it's installed and "
│                   "available on your PYTHONPATH environment variable? Did you "
│                   "forget to activate a virtual environment?"
│               ) from exc
│           execute_from_command_line(sys.argv)
│       
│       
│       if __name__ == '__main__':
│           main()
│       
│   ]
├───messaging
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       
│       # Register your models here.
│       from .models import UserSaga, UserSagaStep
│       
│       
│       admin.site.register(UserSaga)
│       admin.site.register(UserSagaStep)
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class MessagingConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'messaging'
│       
│   ]
│   event_publisher.py
│   [
│       from .rabbitmq_client import rabbitmq_client
│       
│       class AuthEventPublisher:
│           def publish_user_deletion_initiated(self, user_id):
│               event_name = "user.deletion.initiated"
│               payload = {"user_id": str(user_id)}
│               rabbitmq_client.publish(
│                   exchange_name='user_events', # A new exchange for user-level events
│                   routing_key=event_name,
│                   body=payload
│               )
│       
│       event_publisher = AuthEventPublisher()
│   ]
│   ├───management
│   │   __init__.py
│   │   [
│   │       
│   │   ]
│   │   └───commands
│   │       __init__.py
│   │       [
│   │           
│   │       ]
│   │       run_user_saga_finalizer.py
│   │       [
│   │           # auth_service/messaging/management/commands/run_user_saga_finalizer.py
│   │           
│   │           import pika
│   │           import json
│   │           from django.core.management.base import BaseCommand
│   │           from django.db import transaction
│   │           
│   │           # Correctly importing the models defined in accounts/models.py
│   │           from accounts.models import User
│   │           from messaging.models import UserSaga, UserSagaStep
│   │           from django.conf import settings
│   │           
│   │           class Command(BaseCommand):
│   │               help = 'Runs a worker to finalize user deletion sagas.'
│   │           
│   │               def handle(self, *args, **options):
│   │                   connection = pika.BlockingConnection(pika.URLParameters(settings.RABBITMQ_URL))
│   │                   channel = connection.channel()
│   │           
│   │                   # Declare exchanges this worker needs to listen to
│   │                   channel.exchange_declare(exchange='user_events', exchange_type='topic', durable=True)
│   │                   
│   │                   queue_name = 'user_finalizer_queue'
│   │                   channel.queue_declare(queue=queue_name, durable=True)
│   │                   
│   │                   # Bind to both types of confirmation events
│   │                   channel.queue_bind(exchange='user_events', queue=queue_name, routing_key='resource.for_user.deleted.*')
│   │                   channel.queue_bind(exchange='user_events', queue=queue_name, routing_key='all_projects_for_user.deleted')
│   │                   
│   │                   self.stdout.write(' [*] User Saga Finalizer waiting for messages.')
│   │           
│   │                   def callback(ch, method, properties, body):
│   │                       data = json.loads(body)
│   │                       routing_key = method.routing_key
│   │                       user_id = data.get('user_id')
│   │           
│   │                       service_name = None
│   │                       if routing_key.startswith('resource.for_user.deleted.'):
│   │                           # e.g., 'resource.for_user.deleted.AIModelService' -> 'AIModelService'
│   │                           service_name = routing_key.split('.')[-1]
│   │                       elif routing_key == 'all_projects_for_user.deleted':
│   │                           service_name = 'ProjectService'
│   │           
│   │                       if not service_name or not user_id:
│   │                           self.stderr.write(f" [!] Invalid message received. Key: {routing_key}, Body: {data}")
│   │                           ch.basic_ack(delivery_tag=method.delivery_tag)
│   │                           return
│   │           
│   │                       self.stdout.write(f" [x] Received confirmation from '{service_name}' for user '{user_id}'")
│   │           
│   │                       try:
│   │                           with transaction.atomic():
│   │                               # Find the specific saga that is currently in progress for this user
│   │                               saga = UserSaga.objects.select_for_update().get(user_id=user_id, status=UserSaga.SagaStatus.IN_PROGRESS)
│   │                               
│   │                               # Find the corresponding step for the service that just reported back
│   │                               step = saga.steps.select_for_update().get(service_name=service_name)
│   │                               
│   │                               # Idempotency check: If we've already processed this confirmation, do nothing.
│   │                               if step.status == UserSagaStep.StepStatus.COMPLETED: # <--- CORRECTED MODEL NAME
│   │                                   self.stdout.write(f" [!] Step for {service_name} already completed. Ignoring duplicate.")
│   │                                   ch.basic_ack(delivery_tag=method.delivery_tag)
│   │                                   return
│   │           
│   │                               # Mark the step as complete
│   │                               step.status = UserSagaStep.StepStatus.COMPLETED # <--- CORRECTED MODEL NAME
│   │                               step.save()
│   │           
│   │                               # Check if all steps for this saga are now finished
│   │                               if not saga.steps.filter(status=UserSagaStep.StepStatus.PENDING).exists(): # <--- CORRECTED MODEL NAME
│   │                                   self.stdout.write(f" [!] All steps for user saga {saga.id} complete. Finalizing user deletion.")
│   │                                   
│   │                                   # HARD DELETE the user from the database
│   │                                   User.objects.filter(id=user_id).delete()
│   │                                   
│   │                                   # Mark the entire saga as complete
│   │                                   saga.status = UserSaga.SagaStatus.COMPLETED
│   │                                   saga.save()
│   │                                   self.stdout.write(f" [!] User {user_id} deleted and saga completed.")
│   │                       
│   │                       except UserSaga.DoesNotExist:
│   │                           self.stderr.write(f" [!] Warning: Received confirmation for an unknown or completed saga. User ID: {user_id}")
│   │                       except UserSagaStep.DoesNotExist: # <--- CORRECTED MODEL NAME
│   │                           self.stderr.write(f" [!] Warning: Received confirmation from an unexpected service '{service_name}' for saga on User ID: {user_id}")
│   │                       except Exception as e:
│   │                           self.stderr.write(f" [!] Error processing message: {e}")
│   │                           # In production, you'd add logic here to nack (not acknowledge) the message
│   │                           # so it can be retried or sent to a Dead Letter Queue.
│   │           
│   │                       # Acknowledge the message was processed successfully
│   │                       ch.basic_ack(delivery_tag=method.delivery_tag)
│   │           
│   │                   channel.basic_consume(queue=queue_name, on_message_callback=callback)
│   │                   channel.start_consuming()
│   │       ]
│   models.py
│   [
│       import uuid
│       from django.db import models
│       
│       class UserSaga(models.Model):
│           class SagaStatus(models.TextChoices):
│               IN_PROGRESS = 'in_progress', 'In Progress'
│               COMPLETED = 'completed', 'Completed'
│               FAILED = 'failed', 'Failed'
│       
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           user_id = models.UUIDField(db_index=True, unique=True) # The user being deleted
│           status = models.CharField(max_length=50, choices=SagaStatus.choices, default=SagaStatus.IN_PROGRESS)
│           created_at = models.DateTimeField(auto_now_add=True)
│           updated_at = models.DateTimeField(auto_now=True)
│       
│       class UserSagaStep(models.Model):
│           class StepStatus(models.TextChoices):
│               PENDING = 'pending', 'Pending'
│               COMPLETED = 'completed', 'Completed'
│       
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           saga = models.ForeignKey(UserSaga, on_delete=models.CASCADE, related_name="steps")
│           service_name = models.CharField(max_length=100)
│           status = models.CharField(max_length=50, choices=StepStatus.choices, default=StepStatus.PENDING)
│           updated_at = models.DateTimeField(auto_now=True)
│       
│           class Meta:
│               unique_together = ('saga', 'service_name')
│   ]
│   rabbitmq_client.py
│   [
│       import pika
│       import json
│       import threading
│       import time
│       from django.conf import settings
│       
│       class RabbitMQClient:
│           """
│           A robust, thread-safe RabbitMQ client that manages connections on a per-thread
│           basis, uses a fresh channel per operation, and includes an automatic retry
│           mechanism for publishing messages to handle transient network failures.
│           """
│           _thread_local = threading.local()
│       
│           def __init__(self, max_retries=10, retry_delay=2):
│               self.max_retries = max_retries
│               self.retry_delay = retry_delay
│       
│           def _get_connection(self):
│               """
│               Gets or creates a dedicated connection for the current thread.
│               """
│               if not hasattr(self._thread_local, 'connection') or self._thread_local.connection.is_closed:
│                   print(f"Thread {threading.get_ident()}: No active RabbitMQ connection. Creating new one...")
│                   try:
│                       params = pika.URLParameters(settings.RABBITMQ_URL)
│                       self._thread_local.connection = pika.BlockingConnection(params)
│                       print(f"Thread {threading.get_ident()}: Connection successful.")
│                   except pika.exceptions.AMQPConnectionError as e:
│                       print(f"CRITICAL: Thread {threading.get_ident()} failed to connect to RabbitMQ: {e}")
│                       raise
│               return self._thread_local.connection
│       
│           def _invalidate_connection(self):
│               """Forcefully closes and removes the connection for the current thread."""
│               if hasattr(self._thread_local, 'connection') and self._thread_local.connection.is_open:
│                   self._thread_local.connection.close()
│               if hasattr(self._thread_local, 'connection'):
│                   del self._thread_local.connection
│               print(f"Thread {threading.get_ident()}: Invalidated RabbitMQ connection.")
│       
│           def publish(self, exchange_name, routing_key, body):
│               """
│               Publishes a message with a built-in retry mechanism.
│               """
│               attempt = 0
│               while attempt < self.max_retries:
│                   try:
│                       connection = self._get_connection()
│                       with connection.channel() as channel:
│                           channel.exchange_declare(exchange=exchange_name, exchange_type='topic', durable=True)
│                           message_body = json.dumps(body, default=str)
│                           channel.basic_publish(
│                               exchange=exchange_name,
│                               routing_key=routing_key,
│                               body=message_body,
│                               properties=pika.BasicProperties(
│                                   content_type='application/json',
│                                   delivery_mode=pika.DeliveryMode.Persistent,
│                               )
│                           )
│                           print(f" [x] Sent '{routing_key}':'{message_body}' on attempt {attempt + 1}")
│                           return # --- SUCCESS, exit the loop ---
│       
│                   except (pika.exceptions.AMQPError, OSError) as e:
│                       print(f"WARN: Publish attempt {attempt + 1} failed: {e}. Invalidating connection and retrying...")
│                       self._invalidate_connection() # Invalidate the bad connection
│                       attempt += 1
│                       if attempt < self.max_retries:
│                           time.sleep(self.retry_delay) # Wait before next attempt
│                       else:
│                           print(f"CRITICAL: Failed to publish message after {self.max_retries} attempts.")
│                           raise  # Re-raise the final exception
│       
│       # Create a single, globally accessible instance.
│       rabbitmq_client = RabbitMQClient()
│   ]
│   tests.py
│   [
│       from django.test import TestCase
│       
│       # Create your tests here.
│       
│   ]
│   views.py
│   [
│       from django.shortcuts import render
│       
│       # Create your views here.
│       
│   ]
│   project meta gen.py
│   [
│       import os
│       import mimetypes
│       import glob
│       import re
│       
│       def get_next_sequence_number():
│           """Find the next available sequence number for the output file."""
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           pattern = os.path.join(script_dir, "project_structure_*.txt")
│           existing_files = glob.glob(pattern)
│           
│           if not existing_files:
│               return 1
│           
│           # Extract sequence numbers from existing files
│           sequence_numbers = []
│           for file_path in existing_files:
│               basename = os.path.basename(file_path)
│               match = re.search(r'project_structure_(\d+)\.txt', basename)
│               if match:
│                   sequence_numbers.append(int(match.group(1)))
│           
│           if not sequence_numbers:
│               return 1
│           
│           # Return the next number in sequence
│           return max(sequence_numbers) + 1
│       
│       def generate_project_structure():
│           """Generate a text file containing the project structure with file contents."""
│           # Get the absolute path of the script's directory
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           # Change to that directory to ensure we're working only there
│           os.chdir(script_dir)
│           
│           # Generate a unique filename with sequence number
│           seq_num = get_next_sequence_number()
│           output_file = os.path.join(script_dir, f"project_structure_{seq_num}.txt")
│           
│           with open(output_file, 'w', encoding='utf-8', errors='replace') as f:
│               # Get items in the script directory only, excluding specified patterns
│               items = get_directory_items(script_dir, output_file)
│               
│               # Process each item at root level
│               for i, item in enumerate(items):
│                   is_last = i == len(items) - 1
│                   
│                   if os.path.isdir(os.path.join(script_dir, item)):
│                       # It's a directory
│                       if is_last:
│                           f.write(f"└───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "    ", output_file, script_dir)
│                       else:
│                           f.write(f"├───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "│   ", output_file, script_dir)
│                   else:
│                       # It's a file - at root level, format as in the example
│                       f.write(f"│   {item}\n")
│                       # Include file content
│                       content = read_file_content(os.path.join(script_dir, item))
│                       f.write(f"│   [\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           f.write(f"│       {line}\n")
│                       f.write(f"│   ]\n")
│           
│           print(f"Project structure has been written to {output_file}")
│       
│       def should_exclude(item_path):
│           """Check if an item should be excluded based on patterns."""
│           # Exclude __pycache__ directories
│           if os.path.isdir(item_path) and "__pycache__" in item_path:
│               return True
│           
│           # Exclude migrations directories
│           if os.path.isdir(item_path) and "migrations" in item_path:
│               return True
│           
│           # Exclude .pyc files
│           if item_path.endswith('.pyc'):
│               return True
│           
│           # Exclude all project_structure files
│           if os.path.basename(item_path).startswith("project_structure_") and item_path.endswith(".txt"):
│               return True
│           
│           return False
│       
│       def get_directory_items(dir_path, output_file):
│           """Get sorted list of items in a directory, excluding the output file and specified patterns."""
│           # Get absolute path to output file to exclude it
│           abs_output_path = os.path.abspath(output_file)
│           
│           try:
│               # List directory contents
│               items = sorted(os.listdir(dir_path))
│               
│               # Filter out the output file itself and items matching exclude patterns
│               filtered_items = []
│               for item in items:
│                   item_path = os.path.join(dir_path, item)
│                   
│                   # Skip the output file
│                   if os.path.abspath(item_path) == abs_output_path:
│                       continue
│                       
│                   # Skip symlinks that might point outside
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   # Skip items matching exclude patterns
│                   if should_exclude(item_path):
│                       continue
│                       
│                   filtered_items.append(item)
│               
│               return filtered_items
│           except Exception as e:
│               print(f"Error listing directory {dir_path}: {e}")
│               return []
│       
│       def is_binary_file(file_path):
│           """Determine if a file is binary or text."""
│           # Initialize mimetypes
│           if not mimetypes.inited:
│               mimetypes.init()
│           
│           # Check by mime type first
│           mime_type, _ = mimetypes.guess_type(file_path)
│           if mime_type and not mime_type.startswith(('text/', 'application/json', 'application/xml', 'application/javascript')):
│               return True
│               
│           # Fallback: check for null bytes
│           try:
│               with open(file_path, 'rb') as f:
│                   chunk = f.read(4096)
│                   return b'\0' in chunk
│           except Exception:
│               return True  # If we can't read it, assume binary
│       
│       def read_file_content(file_path, max_length=500000):
│           """Read content from a file, handling binary files and errors."""
│           try:
│               # Check if binary
│               if is_binary_file(file_path):
│                   return "[Binary file - content not shown]"
│                   
│               # Read text file
│               with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
│                   content = f.read(max_length + 1)
│                   
│               # Handle truncation
│               if len(content) > max_length:
│                   content = content[:max_length] + "... [truncated]"
│                   
│               # Return raw content without escaping special characters
│               return content
│           except Exception as e:
│               return f"[Error reading file: {str(e)}]"
│       
│       def process_directory(dir_path, file_obj, indent, output_file, script_dir):
│           """Recursively process a directory and write its structure to the file."""
│           # Safety check - ensure we're still within the script directory
│           rel_path = os.path.relpath(dir_path, script_dir)
│           if rel_path.startswith('..') or rel_path == '.':
│               return  # Don't process if it's outside our script directory
│           
│           try:
│               # List directory contents
│               items = get_directory_items(dir_path, output_file)
│               
│               # Process each item
│               for i, item in enumerate(items):
│                   item_path = os.path.join(dir_path, item)
│                   is_last = i == len(items) - 1
│                   
│                   # Safety check - don't follow symlinks or items outside our script directory
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   rel_path = os.path.relpath(item_path, script_dir)
│                   if rel_path.startswith('..'):
│                       continue
│                   
│                   if os.path.isdir(item_path):
│                       # It's a directory
│                       if is_last:
│                           file_obj.write(f"{indent}└───{item}\n")
│                           process_directory(item_path, file_obj, indent + "    ", output_file, script_dir)
│                       else:
│                           file_obj.write(f"{indent}├───{item}\n")
│                           process_directory(item_path, file_obj, indent + "│   ", output_file, script_dir)
│                   else:
│                       # It's a file
│                       file_obj.write(f"{indent}{item}\n")
│                       # Include file content
│                       content = read_file_content(item_path)
│                       file_obj.write(f"{indent}[\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           file_obj.write(f"{indent}    {line}\n")
│                       file_obj.write(f"{indent}]\n")
│           except PermissionError:
│               file_obj.write(f"{indent}[Permission denied]\n")
│           except Exception as e:
│               file_obj.write(f"{indent}[Error: {str(e)}]\n")
│       
│       if __name__ == "__main__":
│           generate_project_structure()
│   ]
│   requirements.txt
│   [
│       [Binary file - content not shown]
│   ]
