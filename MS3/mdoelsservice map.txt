│   .env
│   [
│       # Django's main secret key
│       DJANGO_SECRET_KEY='django-insecure-m3x$8o#H45Ysdverg56564ldpcuck6bytc4h1*8v!=8(_wau6g8or'
│       JWT_SECRET_KEY ='jwt-secure-m3x$DFGRTJRTYNEHRETNEFDDHD43.m<?><DFGRTJYRJGc4h1*8v!=8(_wau6g8or'
│       # You can also add other environment-specific settings here
│       DJANGO_DEBUG='True'
│       DATABASE_URL='sqlite:///./db.sqlite3' # Example for database config
│       JWT_ISSUER="https://ms1.auth-service.com"
│       RABBITMQ_URL='amqp://guest:guest@localhost:5672/'
│       NODE_SERVICE_URL='http://localhost:8003'
│   ]
├───MS3
│   __init__.py
│   [
│       
│   ]
│   asgi.py
│   [
│       """
│       ASGI config for MS3 project.
│       
│       It exposes the ASGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
│       """
│       
│       import os
│       
│       from django.core.asgi import get_asgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS3.settings')
│       
│       application = get_asgi_application()
│       
│   ]
│   settings.py
│   [
│       """
│       Django settings for MS3 project.
│       
│       Generated by 'django-admin startproject' using Django 5.2.4.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/topics/settings/
│       
│       For the full list of settings and their values, see
│       https://docs.djangoproject.com/en/5.2/ref/settings/
│       """
│       from datetime import timedelta
│       from pathlib import Path
│       import os
│       # Build paths inside the project like this: BASE_DIR / 'subdir'.
│       BASE_DIR = Path(__file__).resolve().parent.parent
│       
│       from dotenv import load_dotenv
│       load_dotenv(BASE_DIR / '.env')
│       # Quick-start development settings - unsuitable for production
│       # See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/
│       
│       SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
│       if not SECRET_KEY:
│           # This fallback should ideally not be hit if .env is loaded correctly
│           # or if the environment variable is set directly in the deployment environment.
│           SECRET_KEY = 'django-insecure-fallback-dev-key-!!change-me!!'
│           print("WARNING: DJANGO_SECRET_KEY not found in environment or .env. Using fallback. THIS IS INSECURE FOR PRODUCTION.")
│       
│       DEBUG = os.getenv('DJANGO_DEBUG', 'True').lower() in ('true', '1', 't')
│       
│       ALLOWED_HOSTS = ['*']
│       
│       # Application definition
│       
│       INSTALLED_APPS = [
│       
│           'django.contrib.admin',
│           'django.contrib.auth',
│           'django.contrib.contenttypes',
│           'django.contrib.sessions',
│           'django.contrib.messages',
│           'django.contrib.staticfiles',
│           'rest_framework',
│           'rest_framework_simplejwt',
│           'aimodels',
│           'aimodelsinternal',
│           'messaging' 
│       ]
│       
│       MIDDLEWARE = [
│           'django.middleware.security.SecurityMiddleware',
│           'django.contrib.sessions.middleware.SessionMiddleware',
│           'django.middleware.common.CommonMiddleware',
│           'django.middleware.csrf.CsrfViewMiddleware',
│           'django.contrib.auth.middleware.AuthenticationMiddleware',
│           'django.contrib.messages.middleware.MessageMiddleware',
│           'django.middleware.clickjacking.XFrameOptionsMiddleware',
│       ]
│       
│       ROOT_URLCONF = 'MS3.urls'
│       
│       TEMPLATES = [
│           {
│               'BACKEND': 'django.template.backends.django.DjangoTemplates',
│               'DIRS': [],
│               'APP_DIRS': True,
│               'OPTIONS': {
│                   'context_processors': [
│                       'django.template.context_processors.request',
│                       'django.contrib.auth.context_processors.auth',
│                       'django.contrib.messages.context_processors.messages',
│                   ],
│               },
│           },
│       ]
│       
│       WSGI_APPLICATION = 'MS3.wsgi.application'
│       
│       
│       # Database
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#databases
│       
│       DATABASES = {
│           'default': {
│               'ENGINE': 'django.db.backends.sqlite3',
│               'NAME': BASE_DIR / 'db.sqlite3',
│           }
│       }
│       
│       
│       # Password validation
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators
│       
│       AUTH_PASSWORD_VALIDATORS = [
│           {
│               'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
│           },
│       ]
│       
│       
│       # Internationalization
│       # https://docs.djangoproject.com/en/5.2/topics/i18n/
│       
│       LANGUAGE_CODE = 'en-us'
│       
│       TIME_ZONE = 'UTC'
│       
│       USE_I18N = True
│       
│       USE_TZ = True
│       
│       
│       # Static files (CSS, JavaScript, Images)
│       # https://docs.djangoproject.com/en/5.2/howto/static-files/
│       
│       STATIC_URL = '/static/'
│       STATIC_ROOT = BASE_DIR / 'staticfiles'
│       
│       # Default primary key field type
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field
│       
│       DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
│       
│       
│       
│       JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
│       
│       
│       # REST Framework
│       REST_FRAMEWORK = {
│           "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
│           "DEFAULT_AUTHENTICATION_CLASSES": (
│       
│            #
│            #
│          #####
│           ###
│            #        
│               "aimodels.custom_auth.ForceTokenUserJWTAuthentication", # <<< YOUR CUSTOM AUTH CLASS
│           ),
│           
│           'DEFAULT_THROTTLE_CLASSES': (
│               'rest_framework.throttling.AnonRateThrottle',
│               'rest_framework.throttling.UserRateThrottle'
│           ),
│           'DEFAULT_THROTTLE_RATES': {
│               'anon': '100/day',  # Adjust as needed for unauthenticated requests
│               'user': '20000/day' # Adjust as needed for authenticated requests
│           }
│       }
│       SIMPLE_JWT = {
│       
│           "SIGNING_KEY": JWT_SECRET_KEY,  # <<< USE DJANGO'S SECRET_KEY LOADED FROM ENV
│           "VERIFYING_KEY": JWT_SECRET_KEY,
│           "ISSUER": os.getenv('JWT_ISSUER', "https://ms1.auth-service.com"), # MUST match MS1's issuer
│           "AUTH_HEADER_TYPES": ("Bearer",),
│           "ACCESS_TOKEN_LIFETIME": timedelta(minutes=60), # e.g., 1 hour
│           "REFRESH_TOKEN_LIFETIME": timedelta(days=1),    # e.g., 1 day
│           "LEEWAY": timedelta(seconds=10),
│           "ALGORITHM": "HS256",
│           
│           # --- Settings related to interpreting the token payload ---
│           """
│       "USER_ID_CLAIM": "user_id": (Your Specific Question)
│        This is a critical instruction. It tells simple-jwt:
│          "When you parse the token's payload (the data inside),
│            the claim that contains the user's primary identifier is named 'user_id'."
│              Your MS1's CustomTokenObtainPairSerializer probably adds a claim with this name.
│           """
│       
│           "USER_ID_CLAIM": "user_id",
│           "USER_ID_FIELD": "id",
│           "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser", # Explicitly use TokenUse
│       
│           # --- Settings for features MS2 likely DOES NOT use ---
│           "UPDATE_LAST_LOGIN": False,
│           "ROTATE_REFRESH_TOKENS": False,
│           "BLACKLIST_AFTER_ROTATION": False, 
│       
│       }
│       
│       
│       
│       # RabbitMQ Settings
│       RABBITMQ_URL = os.getenv('RABBITMQ_URL', 'amqp://guest:guest@localhost:5672/')
│       
│       # Node Service URL
│       NODE_SERVICE_URL = os.getenv('NODE_SERVICE_URL', 'http://localhost:8003')
│   ]
│   urls.py
│   [
│       from django.contrib import admin
│       from django.urls import path, include
│       
│       urlpatterns = [
│           # Wrap all paths under the 'ms3/' prefix
│           path('ms3/', include([
│               path('admin/', admin.site.urls),
│               path('api/v1/', include('aimodels.urls')),
│               path('internal/v1/', include('aimodelsinternal.internal_urls')),
│           ]))
│       ]
│   ]
│   views.py
│   [
│       from django.contrib.auth.decorators import login_required
│       from django.http import HttpResponse
│       from django.views.static import serve
│       from django.conf import settings
│       
│       # Protected media view
│       def protected_media_view(request, path):
│           if not request.user.is_authenticated:
│               return HttpResponse('Unauthorized', status=401)
│           # Add additional permission checks here if needed
│           return serve(request, path, document_root=settings.MEDIA_ROOT)
│       
│   ]
│   wsgi.py
│   [
│       """
│       WSGI config for MS3 project.
│       
│       It exposes the WSGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
│       """
│       
│       import os
│       
│       from django.core.wsgi import get_wsgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS3.settings')
│       
│       application = get_wsgi_application()
│       
│   ]
├───aimodels
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       from .models import AIModel
│       
│       admin.site.register(AIModel)
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class AimodelsConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'aimodels'
│       
│   ]
│   custom_auth.py
│   [
│       from rest_framework_simplejwt.authentication import JWTAuthentication
│       from rest_framework_simplejwt.models import TokenUser # Import TokenUser
│       from rest_framework_simplejwt.settings import api_settings as simple_jwt_settings
│       from django.utils.translation import gettext_lazy as _
│       from rest_framework_simplejwt.exceptions import InvalidToken
│       
│       class ForceTokenUserJWTAuthentication(JWTAuthentication):
│           def get_user(self, validated_token):
│               """
│               Returns a TokenUser instance based on the validated token.
│               Bypasses any local database User lookup for JWT authentication.
│               """
│               try:
│                   # simple_jwt_settings.USER_ID_CLAIM refers to what you set in settings.py
│                   # e.g., "user_id"
│                   user_id = validated_token[simple_jwt_settings.USER_ID_CLAIM]
│               except KeyError:
│                   raise InvalidToken(_("Token contained no recognizable user identification"))
│       
│               # Correct way to instantiate TokenUser: pass the validated_token
│               # The TokenUser class will internally use USER_ID_CLAIM and USER_ID_FIELD
│               # from your SIMPLE_JWT settings to extract the user ID and set its 'id' or 'pk'.
│               token_user = TokenUser(validated_token)
│       
│               # The TokenUser's 'id' (and 'pk') attribute should now be populated correctly
│               # by its own __init__ method based on the validated_token and your SIMPLE_JWT settings
│               # for USER_ID_CLAIM and USER_ID_FIELD.
│       
│               # Example: If you wanted to verify or access it (not strictly necessary here)
│               # print(f"TokenUser ID: {token_user.id}, TokenUser PK: {token_user.pk}")
│       
│               return token_user
│   ]
│   models.py
│   [
│       import uuid
│       from django.db import models
│       
│       class AIModel(models.Model):
│           """
│           A single, unified model representing an AI model configuration.
│           Can be a global 'System Model' (template) or a private 'User Model'.
│           """
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           
│           is_system_model = models.BooleanField(
│               default=False, 
│               db_index=True,
│               help_text="True if this is a global model template managed by an admin."
│           )
│           
│           owner_id = models.UUIDField(
│               db_index=True, 
│               null=True, # A system model has no owner.
│               blank=True,
│               help_text="The user who owns this configuration. NULL for system models."
│           )
│           
│           name = models.CharField(
│               max_length=255, 
│               help_text="User-friendly name (e.g., 'My Personal GPT-4o' or 'System Llama 3')."
│           )
│           
│           provider = models.CharField(
│               max_length=100,
│               db_index=True,
│               help_text="Provider identifier (e.g., 'openai', 'ollama', 'anthropic')."
│           )
│           
│           configuration = models.JSONField(
│               default=dict,
│               help_text="For system models: the JSON schema. For user models: the encrypted config values."
│           )
│           
│           capabilities = models.JSONField(
│               default=list, 
│               help_text="List of capabilities (e.g., ['text', 'vision', 'tool_use'])."
│           )
│           
│           created_at = models.DateTimeField(auto_now_add=True, editable=False)
│           updated_at = models.DateTimeField(auto_now=True)
│       
│           class Meta:
│               ordering = ['-is_system_model', 'provider', 'name']
│               constraints = [
│                   models.UniqueConstraint(fields=['owner_id', 'name'], name='unique_user_model_name')
│               ]
│               verbose_name = "AI Model Configuration" 
│       
│           def __str__(self):
│               model_type = 'System' if self.is_system_model else f"User ({self.owner_id})"
│               return f"{self.name} [{self.provider}] ({model_type})"
│   ]
│   permissions.py
│   [
│       # in aimodels/permissions.py
│       
│       from rest_framework import permissions
│       from .models import AIModel
│       
│       class IsOwnerOrReadOnly(permissions.BasePermission):
│           def has_object_permission(self, request, view, obj):
│               
│               # --- START OF DEBUGGING BLOCK ---
│               print("\n--- PERMISSION CHECK ---")
│               
│               # 1. What user object are we getting?
│               print(f"Request User Object: {request.user}")
│               print(f"Type of Request User: {type(request.user)}")
│               
│               # 2. What is the ID on that user object?
│               user_id = getattr(request.user, 'id', 'USER_ID_NOT_FOUND')
│               print(f"Request User ID: {user_id}")
│               print(f"Type of User ID: {type(user_id)}")
│               
│               # 3. What is the owner_id on the database object we're checking?
│               owner_id_on_object = getattr(obj, 'owner_id', 'OWNER_ID_NOT_FOUND')
│               print(f"Object's Owner ID: {owner_id_on_object}")
│               print(f"Type of Object's Owner ID: {type(owner_id_on_object)}")
│               
│               # 4. What is the result of the comparison?
│               is_owner = str(owner_id_on_object) == str(user_id)
│               print(f"Comparing '{str(owner_id_on_object)}' == '{str(user_id)}' -> Result: {is_owner}")
│               
│               print("--- END PERMISSION CHECK ---\n")
│               # --- END OF DEBUGGING BLOCK ---
│       
│               if request.method in permissions.SAFE_METHODS:
│                   return True
│       
│               if obj.owner_id and request.user and request.user.is_authenticated:
│                   return str(obj.owner_id) == str(request.user.id)
│                   
│               return False
│   ]
│   serializers.py
│   [
│       from rest_framework import serializers
│       from .models import AIModel
│       
│       class AIModelSerializer(serializers.ModelSerializer):
│           class Meta:
│               model = AIModel
│               fields = ['id', 'name', 'provider', 'is_system_model', 'owner_id', 'configuration', 'capabilities']
│               read_only_fields = ['id', 'owner_id', 'is_system_model']
│               
│           def to_representation(self, instance):
│               ret = super().to_representation(instance)
│               if not instance.is_system_model:
│                   sanitized_config = {key: "******" for key in ret.get('configuration', {}).keys()}
│                   ret['configuration'] = sanitized_config
│               return ret
│       
│       class AIModelCreateSerializer(serializers.Serializer):
│           name = serializers.CharField(max_length=255, required=True)
│           provider = serializers.CharField(max_length=100, required=True)
│           configuration = serializers.JSONField(required=True)
│       
│       class AIModelUpdateSerializer(serializers.Serializer):
│           name = serializers.CharField(max_length=255, required=True)
│           configuration = serializers.JSONField(required=True)
│       
│           capabilities = serializers.ListField(
│               child=serializers.CharField(),
│               required=False # It's optional; the user doesn't have to provide it.
│           )
│   ]
│   services.py
│   [
│       # in aimodels/services.py (Corrected and Final Version)
│       
│       from django.db.models import Q
│       from .models import AIModel
│       from rest_framework.exceptions import ValidationError, PermissionDenied
│       import jsonschema
│       
│       # --- Placeholder Encryption (as before) ---
│       def encrypt_values(raw_values: dict, schema: dict) -> dict:
│           encrypted = {}
│           for key, value in raw_values.items():
│               if schema.get('properties', {}).get(key, {}).get('sensitive'):
│                   encrypted[key] = f"ENCRYPTED({value[::-1]})"
│               else:
│                   encrypted[key] = value
│           return encrypted
│       
│       # --- The Final Service Class ---
│       class AIModelService:
│           def get_available_models_for_user(self, user_id):
│               """ Returns all system models + the user's own private models. """
│               return AIModel.objects.filter(
│                   Q(is_system_model=True) | Q(owner_id=user_id)
│               )
│       
│           def get_model_by_id(self, model_id, user_id):
│               """
│               Retrieves a single model, ensuring the user has permission to view it.
│               (A user can view any system model or their own models).
│               """
│               try:
│                   model = AIModel.objects.get(id=model_id)
│               except AIModel.DoesNotExist:
│                   raise ValidationError("Model not found.") # This will result in a 404/400
│       
│               # --- THE CRITICAL FIX IS HERE ---
│               # If it's a system model, anyone can view it.
│               # If it's NOT a system model, the owner_id MUST match the user_id.
│               is_owner = str(model.owner_id) == str(user_id)
│               
│               if not model.is_system_model and not is_owner:
│                   raise PermissionDenied("You do not have permission to access this model.")
│                   
│               return model
│       
│           def create_user_model(self, *, owner_id, name, provider, configuration):
│               """ Creates a new private model configuration for a user. """
│               # (This method was already correct, but we include it for completeness)
│               try:
│                   blueprint = AIModel.objects.get(provider=provider, is_system_model=True)
│               except AIModel.DoesNotExist:
│                   raise ValidationError(f"No system model template found for provider '{provider}'.")
│                   
│               schema = blueprint.configuration
│               try:
│                   jsonschema.validate(instance=configuration, schema=schema)
│               except jsonschema.ValidationError as e:
│                   raise ValidationError(f"Configuration is invalid for '{provider}': {e.message}")
│                   
│               encrypted_config = encrypt_values(configuration, schema)
│               
│               user_model = AIModel.objects.create(
│                   is_system_model=False,
│                   owner_id=owner_id,
│                   name=name,
│                   provider=provider,
│                   configuration=encrypted_config,
│                   capabilities=blueprint.capabilities
│               )
│               return user_model
│       
│           def update_user_model(self, *, model_id, user_id, name, configuration, capabilities=None):
│               """
│               Updates a user's private model configuration.
│               Now also handles updates to capabilities.
│               """
│               # Step 1: Get the model (this also performs permission checks)
│               model_to_update = self.get_model_by_id(model_id, user_id)
│               
│               if model_to_update.is_system_model:
│                   raise PermissionDenied("System models cannot be modified.")
│                   
│               # Step 2: Validate the configuration against the blueprint (unchanged)
│               blueprint = AIModel.objects.get(provider=model_to_update.provider, is_system_model=True)
│               schema = blueprint.configuration
│               try:
│                   jsonschema.validate(instance=configuration, schema=schema)
│               except jsonschema.ValidationError as e:
│                   raise ValidationError(f"Configuration is invalid: {e.message}")
│                   
│               # Step 3: Update the model's fields
│               model_to_update.name = name
│               model_to_update.configuration = encrypt_values(configuration, schema) # Placeholder encryption
│               
│               # --- THE CHANGE IS HERE ---
│               # If the 'capabilities' argument was passed, update that field as well.
│               if capabilities is not None:
│                   model_to_update.capabilities = capabilities
│               # --- END OF CHANGE ---
│                   
│               model_to_update.save()
│               return model_to_update
│       
│           def delete_user_model(self, *, model_id, user_id):
│               """ Deletes a user's private model configuration. """
│               model_to_delete = self.get_model_by_id(model_id, user_id)
│               
│               if model_to_delete.is_system_model:
│                    raise PermissionDenied("System models cannot be deleted.")
│                    
│               model_to_delete.delete()
│               # No return value needed for a successful delete.
│   ]
│   tests.py
│   [
│       from django.test import TestCase
│       
│       # Create your tests here.
│       
│   ]
│   urls.py
│   [
│       # in aimodels/urls.py
│       
│       from django.urls import path
│       from .views import AIModelListCreateAPIView, AIModelDetailAPIView
│       
│       urlpatterns = [
│           # Route for listing all models and creating a new one
│           # Handles GET and POST requests.
│           path('models/', AIModelListCreateAPIView.as_view(), name='model-list-create'),
│           
│           # Route for dealing with a specific model by its UUID primary key
│           # Handles GET, PUT, and DELETE requests.
│           path('models/<uuid:pk>/', AIModelDetailAPIView.as_view(), name='model-detail'),
│       ]
│   ]
│   views.py
│   [
│       # in aimodels/views.py
│       
│       import json
│       from rest_framework.views import APIView
│       from rest_framework.response import Response
│       from rest_framework import status, permissions
│       from rest_framework.exceptions import ValidationError, PermissionDenied
│       import httpx
│       from django.conf import settings
│       
│       from .models import AIModel
│       from .services import AIModelService
│       from .serializers import AIModelSerializer, AIModelCreateSerializer, AIModelUpdateSerializer
│       from .permissions import IsOwnerOrReadOnly
│       from messaging.event_publisher import aimodel_event_publisher  # Add this import if aimodel_event_publisher is defined in events.py
│       
│       class AIModelListCreateAPIView(APIView):
│           """
│           Handles listing available models and creating a new user-owned model.
│           Delegates all logic to the AIModelService.
│           """
│           permission_classes = [permissions.IsAuthenticated]
│           service = AIModelService()
│       
│           def get(self, request):
│               """ Handles GET requests to list models. """
│               models = self.service.get_available_models_for_user(user_id=request.user.id)
│               serializer = AIModelSerializer(models, many=True)
│               return Response(serializer.data)
│       
│           def post(self, request):
│               """ Handles POST requests to create a new model. """
│               serializer = AIModelCreateSerializer(data=request.data)
│               serializer.is_valid(raise_exception=True)
│               
│               try:
│                   new_model = self.service.create_user_model(
│                       owner_id=request.user.id,
│                       **serializer.validated_data
│                   )
│                   response_serializer = AIModelSerializer(new_model)
│                   return Response(response_serializer.data, status=status.HTTP_201_CREATED)
│               except (ValidationError, PermissionDenied) as e:
│                   # Catch business logic exceptions from the service and format them correctly.
│                   return Response({"error": str(e)}, status=e.status_code)
│               except Exception:
│                    # Catch any other unexpected errors from the service.
│                   return Response({"error": "An unexpected error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
│       
│       class AIModelDetailAPIView(APIView):
│           """
│           Handles retrieving, updating, and deleting a specific model instance.
│           Delegates all logic to the AIModelService.
│           """
│           permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
│           service = AIModelService()
│       
│           def get_object(self, pk):
│               """
│               Helper method to fetch the object from the DB.
│               DRF's permission system will automatically run on the returned object.
│               """
│               try:
│                   obj = AIModel.objects.get(pk=pk)
│               except AIModel.DoesNotExist:
│                   raise status.HTTP_404_NOT_FOUND
│               
│               # Manually trigger the permission check for the object.
│               self.check_object_permissions(self.request, obj)
│               return obj
│       
│           def get(self, request, pk):
│               """ Handles GET requests to retrieve a single model. """
│               try:
│                   model_instance = self.service.get_model_by_id(model_id=pk, user_id=request.user.id)
│                   serializer = AIModelSerializer(model_instance)
│                   return Response(serializer.data)
│               except (ValidationError, PermissionDenied) as e:
│                   return Response({"error": str(e)}, status=e.status_code)
│       
│           def put(self, request, pk):
│               """ Handles PUT requests to update a model. """
│               # --- THE CHANGE IS HERE: Capture the state BEFORE the update ---
│               try:
│                   model_to_update = self.service.get_model_by_id(model_id=pk, user_id=request.user.id)
│                   old_capabilities = set(model_to_update.capabilities)
│               except (ValidationError, PermissionDenied):
│                    # If the model doesn't exist or isn't accessible, we can't get old caps.
│                    # This is fine, we just won't be able to compare later.
│                   old_capabilities = set()
│               # --- END OF CHANGE ---
│       
│               serializer = AIModelUpdateSerializer(data=request.data)
│               serializer.is_valid(raise_exception=True)
│               
│               try:
│                   # The validated_data now contains 'name', 'configuration', and optionally 'capabilities'
│                   updated_model = self.service.update_user_model(
│                       model_id=pk,
│                       user_id=request.user.id,
│                       **serializer.validated_data # <-- Pass all validated data using **
│                   )
│                   
│                   # --- EVENT PUBLISHING LOGIC ---
│                   new_capabilities = set(updated_model.capabilities)
│                   print(f"DEBUG: Old capabilities: {old_capabilities}, New capabilities: {new_capabilities}")
│                   if old_capabilities != new_capabilities:
│                       print(f"INFO: Capabilities changed for model {pk}. Publishing event.")
│                       try:
│                           print(f"nnnnnnnnnnnnnnnnnnged for model {pk}. Publishing event.")
│                           aimodel_event_publisher.publish_capabilities_updated(
│                               model_id=str(updated_model.id),
│                               new_capabilities=list(new_capabilities)
│                           )
│                       except Exception as e:
│                           print(f"CRITICAL ALERT: Model {pk} capabilities updated, but event publishing failed: {e}")
│                   # --- END OF EVENT LOGIC ---
│       
│                   response_serializer = AIModelSerializer(updated_model)
│                   return Response(response_serializer.data)
│               except (ValidationError, PermissionDenied) as e:
│                   return Response({"error": str(e)}, status=e.status_code)
│       
│           def delete(self, request, pk):
│               # STEP 1: Attempt the deletion and perform all validation first.
│               try:
│                   self.service.delete_user_model(model_id=pk, user_id=request.user.id)
│               except (PermissionDenied, ValidationError) as e:
│                   return Response({"error": str(e)}, status=e.status_code)
│       
│               # STEP 2: If successful, publish the 'model.deleted' event.
│               try:
│                   aimodel_event_publisher.publish_model_deleted(model_id=str(pk))
│               except Exception as e:
│                   print(f"CRITICAL ALERT: Model {pk} was deleted, but 'model.deleted' event publishing failed: {e}")
│       
│               return Response(status=status.HTTP_204_NO_CONTENT)
│   ]
├───aimodelsinternal
│   __init__.py
│   [
│       
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class AimodelsinternalConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'aimodelsinternal'
│       
│   ]
│   internal_urls.py
│   [
│       from django.urls import path
│       from .internal_views import ModelValidationView, ModelCapabilitiesView
│       
│       urlpatterns = [
│           # For the Node Service to check if a user can use a model
│           path('models/<uuid:model_id>/validate', ModelValidationView.as_view(), name='internal-model-validate'),
│           
│           path('models/<uuid:model_id>/capabilities/', ModelCapabilitiesView.as_view(), name='internal-model-capabilities'),
│       ]
│   ]
│   internal_views.py
│   [
│       from rest_framework.views import APIView
│       from rest_framework.response import Response
│       from rest_framework import status, permissions
│       from aimodels.services import AIModelService # Use our existing service layer!
│       
│       class ModelValidationView(APIView):
│           """
│           Internal-only view for other services to validate if a user can
│           access a specific model.
│           """
│           permission_classes = [permissions.IsAuthenticated]
│           service = AIModelService()
│       
│           def get(self, request, model_id):
│               """
│               Uses the service layer's get method, which already contains
│               all the necessary permission logic.
│               """
│               try:
│                   print(f"Validating access for model_id: {model_id} for user: {request.user.id}")
│                   # This method will raise PermissionDenied or ValidationError (NotFound)
│                   # if the user can't access the model.
│                   self.service.get_model_by_id(model_id=model_id, user_id=request.user.id)
│                   print(f"Access validated for model_id: {model_id} for user: {request.user.id}")
│                   # If it doesn't raise an exception, the user is authorized.
│                   return Response(status=status.HTTP_204_NO_CONTENT)
│               
│               except Exception as e:
│                   print(f"Access validation failed for model_id: {model_id} for user: {request.user.id}")
│                   # Let DRF's exception handler format the response (403, 404, etc.)
│                   raise e
│       
│       
│               
│       
│       
│       
│       class ModelCapabilitiesView(APIView):
│           """
│           Internal-only view for other services to quickly fetch the capabilities
│           of a model after validating user access.
│           """
│           permission_classes = [permissions.IsAuthenticated]
│           service = AIModelService()
│       
│           def get(self, request, model_id):
│               try:
│                   # The service method already validates that the user can access this model
│                   model = self.service.get_model_by_id(model_id=model_id, user_id=request.user.id)
│                   
│                   # Return only the capabilities list
│                   return Response({"capabilities": model.capabilities}, status=status.HTTP_200_OK)
│       
│               except Exception as e:
│                   # Let DRF's default exception handler format the 403, 404, etc.
│                   raise e
│   ]
│   model_pb2.py
│   [
│       # -*- coding: utf-8 -*-
│       # Generated by the protocol buffer compiler.  DO NOT EDIT!
│       # NO CHECKED-IN PROTOBUF GENCODE
│       # source: model.proto
│       # Protobuf Python Version: 6.31.1
│       """Generated protocol buffer code."""
│       from google.protobuf import descriptor as _descriptor
│       from google.protobuf import descriptor_pool as _descriptor_pool
│       from google.protobuf import runtime_version as _runtime_version
│       from google.protobuf import symbol_database as _symbol_database
│       from google.protobuf.internal import builder as _builder
│       _runtime_version.ValidateProtobufRuntimeVersion(
│           _runtime_version.Domain.PUBLIC,
│           6,
│           31,
│           1,
│           '',
│           'model.proto'
│       )
│       # @@protoc_insertion_point(imports)
│       
│       _sym_db = _symbol_database.Default()
│       
│       
│       from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
│       
│       
│       DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x0bmodel.proto\x12\x05model\x1a\x1cgoogle/protobuf/struct.proto\"A\n\x1cGetModelConfigurationRequest\x12\x10\n\x08model_id\x18\x01 \x01(\t\x12\x0f\n\x07user_id\x18\x02 \x01(\t\"w\n\x1dGetModelConfigurationResponse\x12\x10\n\x08provider\x18\x01 \x01(\t\x12.\n\rconfiguration\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct\x12\x14\n\x0c\x63\x61pabilities\x18\x03 \x03(\t2r\n\x0cModelService\x12\x62\n\x15GetModelConfiguration\x12#.model.GetModelConfigurationRequest\x1a$.model.GetModelConfigurationResponseb\x06proto3')
│       
│       _globals = globals()
│       _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
│       _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'model_pb2', _globals)
│       if not _descriptor._USE_C_DESCRIPTORS:
│         DESCRIPTOR._loaded_options = None
│         _globals['_GETMODELCONFIGURATIONREQUEST']._serialized_start=52
│         _globals['_GETMODELCONFIGURATIONREQUEST']._serialized_end=117
│         _globals['_GETMODELCONFIGURATIONRESPONSE']._serialized_start=119
│         _globals['_GETMODELCONFIGURATIONRESPONSE']._serialized_end=238
│         _globals['_MODELSERVICE']._serialized_start=240
│         _globals['_MODELSERVICE']._serialized_end=354
│       # @@protoc_insertion_point(module_scope)
│       
│   ]
│   model_pb2_grpc.py
│   [
│       # Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
│       """Client and server classes corresponding to protobuf-defined services."""
│       import grpc
│       import warnings
│       
│       from . import model_pb2 as model__pb2
│       
│       GRPC_GENERATED_VERSION = '1.74.0'
│       GRPC_VERSION = grpc.__version__
│       _version_not_supported = False
│       
│       try:
│           from grpc._utilities import first_version_is_lower
│           _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
│       except ImportError:
│           _version_not_supported = True
│       
│       if _version_not_supported:
│           raise RuntimeError(
│               f'The grpc package installed is at version {GRPC_VERSION},'
│               + f' but the generated code in model_pb2_grpc.py depends on'
│               + f' grpcio>={GRPC_GENERATED_VERSION}.'
│               + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
│               + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
│           )
│       
│       
│       class ModelServiceStub(object):
│           """Missing associated documentation comment in .proto file."""
│       
│           def __init__(self, channel):
│               """Constructor.
│       
│               Args:
│                   channel: A grpc.Channel.
│               """
│               self.GetModelConfiguration = channel.unary_unary(
│                       '/model.ModelService/GetModelConfiguration',
│                       request_serializer=model__pb2.GetModelConfigurationRequest.SerializeToString,
│                       response_deserializer=model__pb2.GetModelConfigurationResponse.FromString,
│                       _registered_method=True)
│       
│       
│       class ModelServiceServicer(object):
│           """Missing associated documentation comment in .proto file."""
│       
│           def GetModelConfiguration(self, request, context):
│               """Authorizes and retrieves the full, decrypted configuration for a model.
│               """
│               context.set_code(grpc.StatusCode.UNIMPLEMENTED)
│               context.set_details('Method not implemented!')
│               raise NotImplementedError('Method not implemented!')
│       
│       
│       def add_ModelServiceServicer_to_server(servicer, server):
│           rpc_method_handlers = {
│                   'GetModelConfiguration': grpc.unary_unary_rpc_method_handler(
│                           servicer.GetModelConfiguration,
│                           request_deserializer=model__pb2.GetModelConfigurationRequest.FromString,
│                           response_serializer=model__pb2.GetModelConfigurationResponse.SerializeToString,
│                   ),
│           }
│           generic_handler = grpc.method_handlers_generic_handler(
│                   'model.ModelService', rpc_method_handlers)
│           server.add_generic_rpc_handlers((generic_handler,))
│           server.add_registered_method_handlers('model.ModelService', rpc_method_handlers)
│       
│       
│        # This class is part of an EXPERIMENTAL API.
│       class ModelService(object):
│           """Missing associated documentation comment in .proto file."""
│       
│           @staticmethod
│           def GetModelConfiguration(request,
│                   target,
│                   options=(),
│                   channel_credentials=None,
│                   call_credentials=None,
│                   insecure=False,
│                   compression=None,
│                   wait_for_ready=None,
│                   timeout=None,
│                   metadata=None):
│               return grpc.experimental.unary_unary(
│                   request,
│                   target,
│                   '/model.ModelService/GetModelConfiguration',
│                   model__pb2.GetModelConfigurationRequest.SerializeToString,
│                   model__pb2.GetModelConfigurationResponse.FromString,
│                   options,
│                   channel_credentials,
│                   insecure,
│                   call_credentials,
│                   compression,
│                   wait_for_ready,
│                   timeout,
│                   metadata,
│                   _registered_method=True)
│       
│   ]
│   ├───protos
│   │   model.proto
│   │   [
│   │       syntax = "proto3";
│   │       
│   │       import "google/protobuf/struct.proto";
│   │       
│   │       package model;
│   │       
│   │       service ModelService {
│   │         // Authorizes and retrieves the full, decrypted configuration for a model.
│   │         rpc GetModelConfiguration(GetModelConfigurationRequest) returns (GetModelConfigurationResponse);
│   │       }
│   │       
│   │       message GetModelConfigurationRequest {
│   │         string model_id = 1;
│   │         string user_id = 2; // User ID from the JWT, for authorization.
│   │       }
│   │       
│   │       message GetModelConfigurationResponse {
│   │         string provider = 1;
│   │         google.protobuf.Struct configuration = 2; // Full, decrypted config (including API keys).
│   │         repeated string capabilities = 3; // e.g., ["text", "vision"]
│   │       }
│   │   ]
│   servicer.py
│   [
│       import grpc
│       from google.protobuf.struct_pb2 import Struct
│       from rest_framework.exceptions import PermissionDenied, ValidationError
│       import logging
│       
│       from . import model_pb2, model_pb2_grpc
│       from aimodels.services import AIModelService
│       
│       # Configure a logger for this servicer
│       logging.basicConfig(level=logging.INFO, format='%(asctime)s - MS3-gRPC - %(levelname)s - %(message)s')
│       logger = logging.getLogger(__name__)
│       
│       class ModelServicer(model_pb2_grpc.ModelServiceServicer):
│           """
│           Implements the gRPC service for AI Models.
│           It acts as a bridge between the gRPC requests and the Django service layer.
│           """
│       
│           def GetModelConfiguration(self, request, context):
│               """
│               Handles the gRPC request to get a model's full configuration.
│               """
│               logger.info(f"Received GetModelConfiguration request for model_id='{request.model_id}' from user_id='{request.user_id}'")
│               
│               service = AIModelService()
│               
│               try:
│                   # The get_model_by_id method contains all authorization logic.
│                   model_instance = service.get_model_by_id(
│                       model_id=request.model_id,
│                       user_id=request.user_id
│                   )
│                   
│                   # This is where decryption would happen in a real implementation.
│                   decrypted_config = model_instance.configuration
│       
│                   # Convert the Python dict configuration to a protobuf Struct
│                   proto_config = Struct()
│                   proto_config.update(decrypted_config)
│                   
│                   logger.info(f"Successfully found and authorized model '{request.model_id}'. Returning configuration.")
│                   return model_pb2.GetModelConfigurationResponse(
│                       provider=model_instance.provider,
│                       configuration=proto_config,
│                       capabilities=model_instance.capabilities
│                   )
│       
│               except PermissionDenied as e:
│                   logger.warning(f"PERMISSION DENIED for model '{request.model_id}': {e}")
│                   context.set_code(grpc.StatusCode.PERMISSION_DENIED)
│                   context.set_details(str(e))
│                   return model_pb2.GetModelConfigurationResponse()
│               except ValidationError as e: # This handles 'Not Found' from your service
│                   logger.warning(f"NOT FOUND for model '{request.model_id}': {e}")
│                   context.set_code(grpc.StatusCode.NOT_FOUND)
│                   context.set_details(str(e))
│                   return model_pb2.GetModelConfigurationResponse()
│               except Exception as e:
│                   logger.error(f"INTERNAL ERROR during GetModelConfiguration for model '{request.model_id}': {e}", exc_info=True)
│                   context.set_code(grpc.StatusCode.INTERNAL)
│                   context.set_details('An internal error occurred in the Model Service.')
│                   return model_pb2.GetModelConfigurationResponse()
│   ]
│   db.sqlite3
│   [
│       [Binary file - content not shown]
│   ]
│   manage.py
│   [
│       #!/usr/bin/env python
│       """Django's command-line utility for administrative tasks."""
│       import os
│       import sys
│       
│       
│       def main():
│           """Run administrative tasks."""
│           os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS3.settings')
│           try:
│               from django.core.management import execute_from_command_line
│           except ImportError as exc:
│               raise ImportError(
│                   "Couldn't import Django. Are you sure it's installed and "
│                   "available on your PYTHONPATH environment variable? Did you "
│                   "forget to activate a virtual environment?"
│               ) from exc
│           execute_from_command_line(sys.argv)
│       
│       
│       if __name__ == '__main__':
│           main()
│       
│   ]
├───messaging
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       
│       # Register your models here.
│       
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class MessagingConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'messaging'
│       
│   ]
│   event_publisher.py
│   [
│       from .rabbitmq_client import rabbitmq_client
│       
│       class AIModelEventPublisher:
│           def publish_model_deleted(self, model_id: str):
│               """
│               Announces that a model has been permanently deleted.
│               """
│               rabbitmq_client.publish(
│                   exchange_name='resource_events',
│                   routing_key='model.deleted',
│                   body={"model_id": model_id}
│               )
│       
│           def publish_capabilities_updated(self, model_id: str, new_capabilities: list):
│               """
│               Announces that a model's capabilities have changed.
│               """
│               rabbitmq_client.publish(
│                   exchange_name='resource_events',
│                   routing_key='model.capabilities.updated',
│                   body={"model_id": model_id, "new_capabilities": new_capabilities}
│               )
│           # --- THIS IS THE MISSING/INCORRECT METHOD THAT CAUSED THE ERROR ---
│           def publish_resource_for_user_deleted(self, user_id: str):
│               """
│               Publishes a confirmation that all AIModels for a given user
│               have been successfully deleted. This is part of the User Deletion Saga.
│               """
│               event_name = "resource.for_user.deleted.AIModelService"
│               payload = {
│                   "user_id": str(user_id),
│                   "service_name": "AIModelService" # Identifies this service as the sender
│               }
│               rabbitmq_client.publish(
│                   exchange_name='user_events', # Publishes to the user_events exchange
│                   routing_key=event_name,
│                   body=payload
│               )
│       aimodel_event_publisher = AIModelEventPublisher()
│   ]
│   ├───management
│   │   __init__.py
│   │   [
│   │       
│   │   ]
│   │   └───commands
│   │       __init__.py
│   │       [
│   │           
│   │       ]
│   │       generate_protos.py
│   │       [
│   │           import os
│   │           import subprocess
│   │           import fileinput
│   │           from django.core.management.base import BaseCommand
│   │           
│   │           class Command(BaseCommand):
│   │               help = 'Generates Python gRPC code from .proto files for the Model Service.'
│   │           
│   │               def handle(self, *args, **options):
│   │                   proto_path = 'aimodelsinternal/protos'
│   │                   output_path = 'aimodelsinternal'
│   │                   
│   │                   if not os.path.exists(proto_path):
│   │                       self.stderr.write(self.style.ERROR(f"Proto path '{proto_path}' does not exist."))
│   │                       return
│   │           
│   │                   proto_files = [f for f in os.listdir(proto_path) if f.endswith('.proto')]
│   │                   if not proto_files:
│   │                       self.stdout.write(self.style.WARNING('No .proto files found.'))
│   │                       return
│   │                       
│   │                   command = [
│   │                       'python', '-m', 'grpc_tools.protoc',
│   │                       f'--proto_path={proto_path}',
│   │                       f'--python_out={output_path}',
│   │                       f'--grpc_python_out={output_path}',
│   │                   ] + proto_files
│   │           
│   │                   self.stdout.write(f"Running command: {' '.join(command)}")
│   │                   try:
│   │                       subprocess.run(command, check=True, capture_output=True, text=True)
│   │                       self.stdout.write(self.style.SUCCESS('Successfully generated gRPC Python stubs for Model Service.'))
│   │                       
│   │                       # --- THE FIX IS HERE ---
│   │                       # After generation, fix the import paths in the _grpc.py file
│   │                       for proto_file in proto_files:
│   │                           base_name = proto_file.replace('.proto', '')
│   │                           grpc_file_path = os.path.join(output_path, f'{base_name}_pb2_grpc.py')
│   │                           
│   │                           self.stdout.write(f"Fixing imports in {grpc_file_path}...")
│   │                           with fileinput.FileInput(grpc_file_path, inplace=True) as file:
│   │                               for line in file:
│   │                                   # Replace 'import model_pb2' with 'from . import model_pb2'
│   │                                   if line.strip() == f'import {base_name}_pb2 as {base_name}__pb2':
│   │                                       print(f'from . import {base_name}_pb2 as {base_name}__pb2')
│   │                                   else:
│   │                                       print(line, end='')
│   │                           self.stdout.write(self.style.SUCCESS('Imports fixed.'))
│   │                       # --- END OF FIX ---
│   │           
│   │                   except subprocess.CalledProcessError as e:
│   │                       self.stderr.write(self.style.ERROR('Failed to generate gRPC stubs.'))
│   │                       self.stderr.write(e.stderr)
│   │       ]
│   │       run_grpc_server.py
│   │       [
│   │           import grpc
│   │           from concurrent import futures
│   │           import time
│   │           from django.core.management.base import BaseCommand
│   │           import django
│   │           import os
│   │           # Setup Django environment
│   │           os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS3.settings')
│   │           django.setup()
│   │           
│   │           from aimodelsinternal import model_pb2_grpc
│   │           from aimodelsinternal.servicer import ModelServicer
│   │           
│   │           
│   │           class Command(BaseCommand):
│   │               help = 'Starts the gRPC server for the Model Service'
│   │           
│   │               def handle(self, *args, **options):
│   │                   self.stdout.write("Starting Model Service gRPC server on port 50052...")
│   │                   
│   │                   server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
│   │                   
│   │                   # Attach your servicer to the server
│   │                   model_pb2_grpc.add_ModelServiceServicer_to_server(ModelServicer(), server)
│   │                   
│   │                   # Start listening
│   │                   server.add_insecure_port('[::]:50052')
│   │                   server.start()
│   │                   self.stdout.write(self.style.SUCCESS('Model Service gRPC server started successfully.'))
│   │                   
│   │                   try:
│   │                       while True:
│   │                           time.sleep(86400) # One day
│   │                   except KeyboardInterrupt:
│   │                       self.stdout.write(self.style.WARNING('Stopping gRPC server...'))
│   │                       server.stop(0)
│   │       ]
│   │       run_user_cleanup_worker.py
│   │       [
│   │           import pika
│   │           import json
│   │           import time
│   │           from django.core.management.base import BaseCommand
│   │           
│   │           # Import the model from the aimodels app and the publisher from the messaging app
│   │           from aimodels.models import AIModel
│   │           from messaging.event_publisher import aimodel_event_publisher
│   │           from django.conf import settings
│   │           
│   │           def handle_user_deletion(user_id: str):
│   │               """
│   │               The core business logic for cleaning up all user-owned AIModels.
│   │               This function is idempotent, meaning running it multiple times for the
│   │               same user_id will not cause errors.
│   │               """
│   │               print(f" [!] Received request to delete AIModels for user: {user_id}")
│   │               
│   │               # Use the Django ORM to find and delete all non-system models owned by this user.
│   │               models_to_delete = AIModel.objects.filter(
│   │                   owner_id=user_id, 
│   │                   is_system_model=False
│   │               )
│   │               
│   │               deleted_count = models_to_delete.count()
│   │               if deleted_count > 0:
│   │                   models_to_delete.delete()
│   │               
│   │               print(f" [✓] Deleted {deleted_count} user-owned AIModels for user {user_id}.")
│   │               
│   │               # After successful deletion, publish the confirmation event.
│   │               # This happens even if the user had 0 models, to signal completion.
│   │               aimodel_event_publisher.publish_resource_for_user_deleted(user_id)
│   │           
│   │           
│   │           class Command(BaseCommand):
│   │               """
│   │               Django management command to run a RabbitMQ worker.
│   │               This worker listens for `user.deletion.initiated` events and cleans up
│   │               all associated user-owned AIModel configurations.
│   │               """
│   │               help = 'Runs a RabbitMQ worker to listen for user deletion events.'
│   │           
│   │               def handle(self, *args, **options):
│   │                   rabbitmq_url = settings.RABBITMQ_URL
│   │           
│   │                   while True:
│   │                       try:
│   │                           connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
│   │                           channel = connection.channel()
│   │           
│   │                           # This worker listens to the user_events exchange.
│   │                           channel.exchange_declare(exchange='user_events', exchange_type='topic', durable=True)
│   │                           
│   │                           # A durable queue for this specific worker.
│   │                           queue_name = 'aimodel_user_cleanup_queue'
│   │                           channel.queue_declare(queue=queue_name, durable=True)
│   │                           
│   │                           # Bind the queue to listen for the specific user deletion event.
│   │                           routing_key = 'user.deletion.initiated'
│   │                           channel.queue_bind(exchange='user_events', queue=queue_name, routing_key=routing_key)
│   │           
│   │                           self.stdout.write(self.style.SUCCESS(' [*] AIModel user cleanup worker waiting for messages. To exit press CTRL+C'))
│   │           
│   │                           def callback(ch, method, properties, body):
│   │                               try:
│   │                                   data = json.loads(body)
│   │                                   user_id = data.get('user_id')
│   │           
│   │                                   if user_id:
│   │                                       # Call the main handler function with the user_id.
│   │                                       handle_user_deletion(user_id)
│   │                                   else:
│   │                                       self.stderr.write(self.style.WARNING(f" [!] Received message without user_id: {body}"))
│   │                               
│   │                               except json.JSONDecodeError:
│   │                                   self.stderr.write(self.style.ERROR(f" [!] Could not decode message body: {body}"))
│   │                               except Exception as e:
│   │                                   self.stderr.write(self.style.ERROR(f" [!] An unexpected error occurred: {e}"))
│   │                                   # Add nack logic for production systems here.
│   │                               
│   │                               # Acknowledge the message was processed (or failed in a way we won't retry).
│   │                               ch.basic_ack(delivery_tag=method.delivery_tag)
│   │           
│   │                           channel.basic_consume(queue=queue_name, on_message_callback=callback)
│   │                           channel.start_consuming()
│   │           
│   │                       except pika.exceptions.AMQPConnectionError:
│   │                           self.stderr.write(self.style.ERROR('Connection to RabbitMQ failed. Retrying in 5 seconds...'))
│   │                           time.sleep(5)
│   │                       except KeyboardInterrupt:
│   │                           self.stdout.write(self.style.SUCCESS(' [!] Stopping worker...'))
│   │                           if 'connection' in locals() and connection.is_open:
│   │                               connection.close()
│   │                           break
│   │       ]
│   models.py
│   [
│       from django.db import models
│       
│       # Create your models here.
│       
│   ]
│   rabbitmq_client.py
│   [
│       # messaging/rabbitmq_client.py (Definitive Resilient Version)
│       
│       import pika
│       import json
│       import threading
│       import time
│       from django.conf import settings
│       
│       class RabbitMQClient:
│           """
│           A robust, thread-safe RabbitMQ client that manages connections on a per-thread
│           basis, uses a fresh channel per operation, and includes an automatic retry
│           mechanism for publishing messages to handle transient network failures.
│           """
│           _thread_local = threading.local()
│       
│           def __init__(self, max_retries=3, retry_delay=2):
│               self.max_retries = max_retries
│               self.retry_delay = retry_delay
│       
│           def _get_connection(self):
│               """
│               Gets or creates a dedicated connection for the current thread.
│               """
│               if not hasattr(self._thread_local, 'connection') or self._thread_local.connection.is_closed:
│                   print(f"Thread {threading.get_ident()}: No active RabbitMQ connection. Creating new one...")
│                   try:
│                       params = pika.URLParameters(settings.RABBITMQ_URL)
│                       self._thread_local.connection = pika.BlockingConnection(params)
│                       print(f"Thread {threading.get_ident()}: Connection successful.")
│                   except pika.exceptions.AMQPConnectionError as e:
│                       print(f"CRITICAL: Thread {threading.get_ident()} failed to connect to RabbitMQ: {e}")
│                       raise
│               return self._thread_local.connection
│       
│           def _invalidate_connection(self):
│               """Forcefully closes and removes the connection for the current thread."""
│               if hasattr(self._thread_local, 'connection') and self._thread_local.connection.is_open:
│                   self._thread_local.connection.close()
│               if hasattr(self._thread_local, 'connection'):
│                   del self._thread_local.connection
│               print(f"Thread {threading.get_ident()}: Invalidated RabbitMQ connection.")
│       
│           def publish(self, exchange_name, routing_key, body):
│               """
│               Publishes a message with a built-in retry mechanism.
│               """
│               attempt = 0
│               while attempt < self.max_retries:
│                   try:
│                       connection = self._get_connection()
│                       with connection.channel() as channel:
│                           channel.exchange_declare(exchange=exchange_name, exchange_type='topic', durable=True)
│                           message_body = json.dumps(body, default=str)
│                           channel.basic_publish(
│                               exchange=exchange_name,
│                               routing_key=routing_key,
│                               body=message_body,
│                               properties=pika.BasicProperties(
│                                   content_type='application/json',
│                                   delivery_mode=pika.DeliveryMode.Persistent,
│                               )
│                           )
│                           print(f" [x] Sent '{routing_key}':'{message_body}' on attempt {attempt + 1}")
│                           return # --- SUCCESS, exit the loop ---
│       
│                   except (pika.exceptions.AMQPError, OSError) as e:
│                       print(f"WARN: Publish attempt {attempt + 1} failed: {e}. Invalidating connection and retrying...")
│                       self._invalidate_connection() # Invalidate the bad connection
│                       attempt += 1
│                       if attempt < self.max_retries:
│                           time.sleep(self.retry_delay) # Wait before next attempt
│                       else:
│                           print(f"CRITICAL: Failed to publish message after {self.max_retries} attempts.")
│                           raise  # Re-raise the final exception
│       
│       # Create a single, globally accessible instance.
│       rabbitmq_client = RabbitMQClient()
│   ]
│   tests.py
│   [
│       from django.test import TestCase
│       
│       # Create your tests here.
│       
│   ]
│   views.py
│   [
│       from django.shortcuts import render
│       
│       # Create your views here.
│       
│   ]
│   project meta gen.py
│   [
│       import os
│       import mimetypes
│       import glob
│       import re
│       
│       def get_next_sequence_number():
│           """Find the next available sequence number for the output file."""
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           pattern = os.path.join(script_dir, "project_structure_*.txt")
│           existing_files = glob.glob(pattern)
│           
│           if not existing_files:
│               return 1
│           
│           # Extract sequence numbers from existing files
│           sequence_numbers = []
│           for file_path in existing_files:
│               basename = os.path.basename(file_path)
│               match = re.search(r'project_structure_(\d+)\.txt', basename)
│               if match:
│                   sequence_numbers.append(int(match.group(1)))
│           
│           if not sequence_numbers:
│               return 1
│           
│           # Return the next number in sequence
│           return max(sequence_numbers) + 1
│       
│       def generate_project_structure():
│           """Generate a text file containing the project structure with file contents."""
│           # Get the absolute path of the script's directory
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           # Change to that directory to ensure we're working only there
│           os.chdir(script_dir)
│           
│           # Generate a unique filename with sequence number
│           seq_num = get_next_sequence_number()
│           output_file = os.path.join(script_dir, f"project_structure_{seq_num}.txt")
│           
│           with open(output_file, 'w', encoding='utf-8', errors='replace') as f:
│               # Get items in the script directory only, excluding specified patterns
│               items = get_directory_items(script_dir, output_file)
│               
│               # Process each item at root level
│               for i, item in enumerate(items):
│                   is_last = i == len(items) - 1
│                   
│                   if os.path.isdir(os.path.join(script_dir, item)):
│                       # It's a directory
│                       if is_last:
│                           f.write(f"└───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "    ", output_file, script_dir)
│                       else:
│                           f.write(f"├───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "│   ", output_file, script_dir)
│                   else:
│                       # It's a file - at root level, format as in the example
│                       f.write(f"│   {item}\n")
│                       # Include file content
│                       content = read_file_content(os.path.join(script_dir, item))
│                       f.write(f"│   [\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           f.write(f"│       {line}\n")
│                       f.write(f"│   ]\n")
│           
│           print(f"Project structure has been written to {output_file}")
│       
│       def should_exclude(item_path):
│           """Check if an item should be excluded based on patterns."""
│           # Exclude __pycache__ directories
│           if os.path.isdir(item_path) and "__pycache__" in item_path:
│               return True
│           
│           # Exclude migrations directories
│           if os.path.isdir(item_path) and "migrations" in item_path:
│               return True
│           
│           # Exclude .pyc files
│           if item_path.endswith('.pyc'):
│               return True
│           
│           # Exclude all project_structure files
│           if os.path.basename(item_path).startswith("project_structure_") and item_path.endswith(".txt"):
│               return True
│           
│           return False
│       
│       def get_directory_items(dir_path, output_file):
│           """Get sorted list of items in a directory, excluding the output file and specified patterns."""
│           # Get absolute path to output file to exclude it
│           abs_output_path = os.path.abspath(output_file)
│           
│           try:
│               # List directory contents
│               items = sorted(os.listdir(dir_path))
│               
│               # Filter out the output file itself and items matching exclude patterns
│               filtered_items = []
│               for item in items:
│                   item_path = os.path.join(dir_path, item)
│                   
│                   # Skip the output file
│                   if os.path.abspath(item_path) == abs_output_path:
│                       continue
│                       
│                   # Skip symlinks that might point outside
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   # Skip items matching exclude patterns
│                   if should_exclude(item_path):
│                       continue
│                       
│                   filtered_items.append(item)
│               
│               return filtered_items
│           except Exception as e:
│               print(f"Error listing directory {dir_path}: {e}")
│               return []
│       
│       def is_binary_file(file_path):
│           """Determine if a file is binary or text."""
│           # Initialize mimetypes
│           if not mimetypes.inited:
│               mimetypes.init()
│           
│           # Check by mime type first
│           mime_type, _ = mimetypes.guess_type(file_path)
│           if mime_type and not mime_type.startswith(('text/', 'application/json', 'application/xml', 'application/javascript')):
│               return True
│               
│           # Fallback: check for null bytes
│           try:
│               with open(file_path, 'rb') as f:
│                   chunk = f.read(4096)
│                   return b'\0' in chunk
│           except Exception:
│               return True  # If we can't read it, assume binary
│       
│       def read_file_content(file_path, max_length=500000):
│           """Read content from a file, handling binary files and errors."""
│           try:
│               # Check if binary
│               if is_binary_file(file_path):
│                   return "[Binary file - content not shown]"
│                   
│               # Read text file
│               with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
│                   content = f.read(max_length + 1)
│                   
│               # Handle truncation
│               if len(content) > max_length:
│                   content = content[:max_length] + "... [truncated]"
│                   
│               # Return raw content without escaping special characters
│               return content
│           except Exception as e:
│               return f"[Error reading file: {str(e)}]"
│       
│       def process_directory(dir_path, file_obj, indent, output_file, script_dir):
│           """Recursively process a directory and write its structure to the file."""
│           # Safety check - ensure we're still within the script directory
│           rel_path = os.path.relpath(dir_path, script_dir)
│           if rel_path.startswith('..') or rel_path == '.':
│               return  # Don't process if it's outside our script directory
│           
│           try:
│               # List directory contents
│               items = get_directory_items(dir_path, output_file)
│               
│               # Process each item
│               for i, item in enumerate(items):
│                   item_path = os.path.join(dir_path, item)
│                   is_last = i == len(items) - 1
│                   
│                   # Safety check - don't follow symlinks or items outside our script directory
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   rel_path = os.path.relpath(item_path, script_dir)
│                   if rel_path.startswith('..'):
│                       continue
│                   
│                   if os.path.isdir(item_path):
│                       # It's a directory
│                       if is_last:
│                           file_obj.write(f"{indent}└───{item}\n")
│                           process_directory(item_path, file_obj, indent + "    ", output_file, script_dir)
│                       else:
│                           file_obj.write(f"{indent}├───{item}\n")
│                           process_directory(item_path, file_obj, indent + "│   ", output_file, script_dir)
│                   else:
│                       # It's a file
│                       file_obj.write(f"{indent}{item}\n")
│                       # Include file content
│                       content = read_file_content(item_path)
│                       file_obj.write(f"{indent}[\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           file_obj.write(f"{indent}    {line}\n")
│                       file_obj.write(f"{indent}]\n")
│           except PermissionError:
│               file_obj.write(f"{indent}[Permission denied]\n")
│           except Exception as e:
│               file_obj.write(f"{indent}[Error: {str(e)}]\n")
│       
│       if __name__ == "__main__":
│           generate_project_structure()
│   ]
│   requirements.txt
│   [
│       asgiref==3.9.1
│       certifi==2025.7.14
│       cffi==1.17.1
│       charset-normalizer==3.4.2
│       cryptography==45.0.5
│       defusedxml==0.7.1
│       Django==5.2.4
│       djangorestframework==3.16.0
│       djangorestframework_simplejwt==5.5.1
│       djoser==2.3.3
│       idna==3.10
│       oauthlib==3.3.1
│       pillow==11.3.0
│       pycparser==2.22
│       PyJWT==2.10.1
│       python3-openid==3.2.0
│       requests==2.32.4
│       requests-oauthlib==2.0.0
│       social-auth-app-django==5.5.1
│       social-auth-core==4.7.0
│       sqlparse==0.5.3
│       tzdata==2025.2
│       urllib3==2.5.0
│       jsonschema
│       dotenv
│       grpcio
│       grpcio-tools
│       protobuf
│       google-api-python-client
│       pika
│       httpx
│       json
│   ]
