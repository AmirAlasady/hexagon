│   .env
│   [
│       # Django's main secret key
│       DJANGO_SECRET_KEY='django-inergegdh5Ysdverg56564ldpcuck6bytc4h1*8v!=8(_wau6g8or'
│       JWT_SECRET_KEY ='jwt-secure-m3x$DFGRTJRTYNEHRETNEFDDHD43.m<?><DFGRTJYRJGc4h1*8v!=8(_wau6g8or'
│       # You can also add other environment-specific settings here
│       DJANGO_DEBUG='True'
│       DATABASE_URL='sqlite:///./db.sqlite3' # Example for database config
│       JWT_ISSUER="https://ms1.auth-service.com"
│       
│       RABBITMQ_URL='amqp://guest:guest@localhost:5672/'
│       
│   ]
├───MS2
│   __init__.py
│   [
│       
│   ]
│   asgi.py
│   [
│       """
│       ASGI config for MS2 project.
│       
│       It exposes the ASGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
│       """
│       
│       import os
│       
│       from django.core.asgi import get_asgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS2.settings')
│       
│       application = get_asgi_application()
│       
│   ]
│   settings.py
│   [
│       
│       from datetime import timedelta
│       import os
│       from pathlib import Path
│       
│       # Build paths inside the project like this: BASE_DIR / 'subdir'.
│       BASE_DIR = Path(__file__).resolve().parent.parent
│       
│       from dotenv import load_dotenv
│       load_dotenv(BASE_DIR / '.env')
│       # Quick-start development settings - unsuitable for production
│       # See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/
│       
│       SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
│       if not SECRET_KEY:
│           # This fallback should ideally not be hit if .env is loaded correctly
│           # or if the environment variable is set directly in the deployment environment.
│           SECRET_KEY = 'django-insecure-fallback-dev-key-!!change-me!!'
│           print("WARNING: DJANGO_SECRET_KEY not found in environment or .env. Using fallback. THIS IS INSECURE FOR PRODUCTION.")
│       
│       DEBUG = os.getenv('DJANGO_DEBUG', 'True').lower() in ('true', '1', 't')
│       
│       ALLOWED_HOSTS = ['*']
│       
│       
│       # Application definition
│       
│       INSTALLED_APPS = [
│       
│           'django.contrib.admin',
│           'django.contrib.auth',
│           'django.contrib.contenttypes',
│           'django.contrib.sessions',
│           'django.contrib.messages',
│           'django.contrib.staticfiles',
│           'rest_framework',
│           'rest_framework_simplejwt',
│           'project',
│           'projectsinternal',
│           'messaging'
│       ]
│       
│       MIDDLEWARE = [
│           'django.middleware.security.SecurityMiddleware',
│           'django.contrib.sessions.middleware.SessionMiddleware',
│           'django.middleware.common.CommonMiddleware',
│           'django.middleware.csrf.CsrfViewMiddleware',
│           'django.contrib.auth.middleware.AuthenticationMiddleware',
│           'django.contrib.messages.middleware.MessageMiddleware',
│           'django.middleware.clickjacking.XFrameOptionsMiddleware',
│       ]
│       
│       ROOT_URLCONF = 'MS2.urls'
│       
│       TEMPLATES = [
│           {
│               'BACKEND': 'django.template.backends.django.DjangoTemplates',
│               'DIRS': [],
│               'APP_DIRS': True,
│               'OPTIONS': {
│                   'context_processors': [
│                       'django.template.context_processors.request',
│                       'django.contrib.auth.context_processors.auth',
│                       'django.contrib.messages.context_processors.messages',
│                   ],
│               },
│           },
│       ]
│       
│       WSGI_APPLICATION = 'MS2.wsgi.application'
│       
│       
│       # Database
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#databases
│       
│       DATABASES = {
│           'default': {
│               'ENGINE': 'django.db.backends.sqlite3',
│               'NAME': BASE_DIR / 'db.sqlite3',
│           }
│       }
│       
│       
│       # Password validation
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators
│       
│       AUTH_PASSWORD_VALIDATORS = [
│           {
│               'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
│           },
│           {
│               'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
│           },
│       ]
│       
│       
│       # Internationalization
│       # https://docs.djangoproject.com/en/5.2/topics/i18n/
│       
│       LANGUAGE_CODE = 'en-us'
│       
│       TIME_ZONE = 'UTC'
│       
│       USE_I18N = True
│       
│       USE_TZ = True
│       
│       
│       # Static files (CSS, JavaScript, Images)
│       # https://docs.djangoproject.com/en/5.2/howto/static-files/
│       
│       STATIC_URL = '/static/'
│       STATIC_ROOT = BASE_DIR / 'staticfiles'
│       
│       
│       # Default primary key field type
│       # https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field
│       
│       DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
│       
│       
│       JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
│       
│       
│       
│       REST_FRAMEWORK = {
│           "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
│           "DEFAULT_AUTHENTICATION_CLASSES": (
│                    
│               "project.custom_auth.ForceTokenUserJWTAuthentication", # <<< YOUR CUSTOM AUTH CLASS
│           ),
│           'DEFAULT_THROTTLE_CLASSES': (
│               'rest_framework.throttling.AnonRateThrottle',
│               'rest_framework.throttling.UserRateThrottle'
│           ),
│           'DEFAULT_THROTTLE_RATES': {
│               'anon': '100/day',  # Adjust as needed for unauthenticated requests
│               'user': '20000/day' # Adjust as needed for authenticated requests
│           }
│       }
│       
│       
│       SIMPLE_JWT = {
│       
│           "SIGNING_KEY": JWT_SECRET_KEY,  # <<< USE DJANGO'S SECRET_KEY LOADED FROM ENV
│           "VERIFYING_KEY": JWT_SECRET_KEY,
│           "ISSUER": os.getenv('JWT_ISSUER', "https://ms1.auth-service.com"), # MUST match MS1's issuer
│           "AUTH_HEADER_TYPES": ("Bearer",),
│           "ACCESS_TOKEN_LIFETIME": timedelta(minutes=60), # e.g., 1 hour
│           "REFRESH_TOKEN_LIFETIME": timedelta(days=1),    # e.g., 1 day
│           "LEEWAY": timedelta(seconds=10),
│           "ALGORITHM": "HS256",
│           
│           # --- Settings related to interpreting the token payload ---
│           """
│       "USER_ID_CLAIM": "user_id": (Your Specific Question)
│        This is a critical instruction. It tells simple-jwt:
│          "When you parse the token's payload (the data inside),
│            the claim that contains the user's primary identifier is named 'user_id'."
│              Your MS1's CustomTokenObtainPairSerializer probably adds a claim with this name.
│           """
│       
│           "USER_ID_CLAIM": "user_id",
│       
│           "USER_ID_FIELD": "id",
│           "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser", # Explicitly use TokenUse
│       
│           # --- Settings for features MS2 likely DOES NOT use ---
│           "UPDATE_LAST_LOGIN": False,
│           "ROTATE_REFRESH_TOKENS": False,
│           "BLACKLIST_AFTER_ROTATION": False, 
│       
│       }
│       
│       
│       RABBITMQ_URL = os.getenv('RABBITMQ_URL', 'amqp://guest:guest@localhost:5672/')
│   ]
│   urls.py
│   [
│       
│       from django.contrib import admin
│       from django.urls import path, include
│       
│       urlpatterns = [
│           # Wrap all paths under the 'ms2/' prefix
│           path('ms2/', include([
│               path('admin/', admin.site.urls),
│               path('api/v1/', include('project.urls')),
│               path('internal/v1/', include('projectsinternal.internal_urls')),
│           ]))
│       ]
│   ]
│   views.py
│   [
│       from django.contrib.auth.decorators import login_required
│       from django.http import HttpResponse
│       from django.views.static import serve
│       from django.conf import settings
│       
│       # Protected media view
│       def protected_media_view(request, path):
│           if not request.user.is_authenticated:
│               return HttpResponse('Unauthorized', status=401)
│           # Add additional permission checks here if needed
│           return serve(request, path, document_root=settings.MEDIA_ROOT)
│       
│   ]
│   wsgi.py
│   [
│       """
│       WSGI config for MS2 project.
│       
│       It exposes the WSGI callable as a module-level variable named ``application``.
│       
│       For more information on this file, see
│       https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
│       """
│       
│       import os
│       
│       from django.core.wsgi import get_wsgi_application
│       
│       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS2.settings')
│       
│       application = get_wsgi_application()
│       
│   ]
│   db.sqlite3
│   [
│       [Binary file - content not shown]
│   ]
│   manage.py
│   [
│       #!/usr/bin/env python
│       """Django's command-line utility for administrative tasks."""
│       import os
│       import sys
│       
│       
│       def main():
│           """Run administrative tasks."""
│           os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MS2.settings')
│           try:
│               from django.core.management import execute_from_command_line
│           except ImportError as exc:
│               raise ImportError(
│                   "Couldn't import Django. Are you sure it's installed and "
│                   "available on your PYTHONPATH environment variable? Did you "
│                   "forget to activate a virtual environment?"
│               ) from exc
│           execute_from_command_line(sys.argv)
│       
│       
│       if __name__ == '__main__':
│           main()
│       
│   ]
├───messaging
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       from .models import Saga, SagaStep
│       # Register your models here.
│       admin.site.register(Saga)
│       admin.site.register(SagaStep)
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class MessagingConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'messaging'
│       
│   ]
│   event_publisher.py
│   [
│       # in project_service/messaging/event_publisher.py
│       from .rabbitmq_client import rabbitmq_client
│       
│       class EventPublisher:
│           """A dedicated class for publishing business-specific events."""
│       
│           def publish_project_deletion_initiated(self, project_id, owner_id):
│               event_name = "project.deletion.initiated"
│               payload = {
│                   "project_id": str(project_id),
│                   "owner_id": str(owner_id)
│               }
│               rabbitmq_client.publish(
│                   exchange_name='project_events',
│                   routing_key=event_name,
│                   body=payload
│               )
│           def publish_all_projects_for_user_deleted(self, user_id):
│               event_name = "all_projects_for_user.deleted"
│               payload = {"user_id": str(user_id)}
│               rabbitmq_client.publish(
│                   exchange_name='user_events', # Publish to the user_events exchange
│                   routing_key=event_name,
│                   body=payload
│               )
│       # Create an instance to be used by the service layer
│       event_publisher = EventPublisher()
│   ]
│   ├───management
│   │   __init__.py
│   │   [
│   │       
│   │   ]
│   │   └───commands
│   │       __init__.py
│   │       [
│   │           
│   │       ]
│   │       run_saga_finalizer_worker.py
│   │       [
│   │           # messaging/management/commands/run_saga_finalizer_worker.py
│   │           
│   │           import pika
│   │           import json
│   │           import time
│   │           from django.core.management.base import BaseCommand
│   │           from django.db import transaction
│   │           from django.conf import settings
│   │           # --- FIX IS HERE ---
│   │           # Use an absolute import path from the top-level app name.
│   │           # Django knows where to find the 'projects' and 'messaging' apps.
│   │           from project.models import Project 
│   │           from messaging.models import Saga, SagaStep
│   │           
│   │           class Command(BaseCommand):
│   │               help = 'Runs a RabbitMQ worker to listen for saga confirmation events.'
│   │           
│   │               def handle(self, *args, **options):
│   │                   # In production, you would use a variable from settings.py for the RabbitMQ URL
│   │                   # For simplicity, we hardcode it here.
│   │                   rabbitmq_url = settings.RABBITMQ_URL
│   │           
│   │                   while True:
│   │                       try:
│   │                           self.stdout.write('Connecting to RabbitMQ...')
│   │                           connection = pika.BlockingConnection(pika.URLParameters(rabbitmq_url))
│   │                           channel = connection.channel()
│   │           
│   │                           # Declare the exchange and a durable queue for this worker
│   │                           channel.exchange_declare(exchange='project_events', exchange_type='topic', durable=True)
│   │                           queue_name = 'project_finalizer_queue'
│   │                           channel.queue_declare(queue=queue_name, durable=True)
│   │                           
│   │                           # We listen for confirmation events.
│   │                           # routing_key format: resource.<resource_name>.<action>
│   │                           # The '#' wildcard listens for all events published to this exchange.
│   │                           # A more specific key would be 'resource.for_project.deleted.*'
│   │                           routing_key = 'resource.for_project.deleted.*'
│   │                           channel.queue_bind(exchange='project_events', queue=queue_name, routing_key=routing_key)
│   │           
│   │                           self.stdout.write(self.style.SUCCESS(' [*] Waiting for confirmation messages. To exit press CTRL+C'))
│   │           
│   │                           def callback(ch, method, properties, body):
│   │                               try:
│   │                                   data = json.loads(body)
│   │                                   project_id = data.get('project_id')
│   │                                   service_name = data.get('service_name')
│   │           
│   │                                   if not project_id or not service_name:
│   │                                       self.stderr.write(self.style.WARNING(f" [!] Received malformed message, discarding: {body}"))
│   │                                       ch.basic_ack(delivery_tag=method.delivery_tag)
│   │                                       return
│   │           
│   │                                   self.stdout.write(f" [x] Received confirmation from '{service_name}' for project '{project_id}'")
│   │           
│   │                                   with transaction.atomic():
│   │                                       # Find the relevant saga. Use select_for_update to lock the row.
│   │                                       try:
│   │                                           saga = Saga.objects.select_for_update().get(
│   │                                               related_resource_id=project_id,
│   │                                               status=Saga.SagaStatus.IN_PROGRESS
│   │                                           )
│   │                                       except Saga.DoesNotExist:
│   │                                           self.stderr.write(self.style.WARNING(f" [!] Warning: Received confirmation for an unknown or completed saga. Project ID: {project_id}"))
│   │                                           ch.basic_ack(delivery_tag=method.delivery_tag)
│   │                                           return
│   │           
│   │                                       # Mark the specific step as completed
│   │                                       step, created = SagaStep.objects.select_for_update().get_or_create(
│   │                                           saga=saga, 
│   │                                           service_name=service_name,
│   │                                           defaults={'status': SagaStep.StepStatus.COMPLETED}
│   │                                       )
│   │                                       if not created and step.status != SagaStep.StepStatus.COMPLETED:
│   │                                           step.status = SagaStep.StepStatus.COMPLETED
│   │                                           step.save()
│   │           
│   │                                       # Check if all steps for this saga are now complete
│   │                                       all_steps_completed = not saga.steps.filter(status=SagaStep.StepStatus.PENDING).exists()
│   │                                       
│   │                                       if all_steps_completed:
│   │                                           self.stdout.write(self.style.SUCCESS(f" [!] All steps for saga {saga.id} complete. Finalizing project deletion."))
│   │                                           
│   │                                           # All confirmations received, perform the hard delete
│   │                                           Project.objects.filter(id=project_id).delete()
│   │                                           
│   │                                           # Mark the saga as complete
│   │                                           saga.status = Saga.SagaStatus.COMPLETED
│   │                                           saga.save()
│   │                                           self.stdout.write(self.style.SUCCESS(f" [!] Project {project_id} deleted and saga completed."))
│   │           
│   │                               except json.JSONDecodeError:
│   │                                   self.stderr.write(self.style.ERROR(f" [!] Could not decode message body: {body}"))
│   │                               except Exception as e:
│   │                                   self.stderr.write(self.style.ERROR(f" [!] An unexpected error occurred: {e}"))
│   │                                   # In a production system, you might 'nack' the message to requeue it
│   │                                   # or route it to a Dead Letter Queue (DLQ). For now, we'll ack to prevent loops.
│   │           
│   │                               # Acknowledge the message so RabbitMQ knows it has been processed.
│   │                               ch.basic_ack(delivery_tag=method.delivery_tag)
│   │           
│   │                           channel.basic_consume(queue=queue_name, on_message_callback=callback)
│   │                           channel.start_consuming()
│   │           
│   │                       except pika.exceptions.AMQPConnectionError:
│   │                           self.stderr.write(self.style.ERROR('Connection to RabbitMQ failed. Retrying in 5 seconds...'))
│   │                           time.sleep(5)
│   │                       except KeyboardInterrupt:
│   │                           self.stdout.write(self.style.SUCCESS('Worker stopped by user.'))
│   │                           break
│   │       ]
│   │       run_user_cleanup_initiator.py
│   │       [
│   │           # project service/messaging/management/commands/run_user_cleanup_initiator.py
│   │           
│   │           import pika
│   │           import json
│   │           import time
│   │           from django.core.management.base import BaseCommand
│   │           from django.db import transaction
│   │           from django.conf import settings
│   │           from project.models import Project, ProjectStatus
│   │           from messaging.models import Saga, SagaStep
│   │           from messaging.event_publisher import event_publisher
│   │           
│   │           def initiate_single_project_deletion_saga(project: Project):
│   │               """
│   │               A reusable function that encapsulates the complete logic for starting
│   │               ONE project deletion saga.
│   │               """
│   │               if Saga.objects.filter(related_resource_id=project.id, status=Saga.SagaStatus.IN_PROGRESS).exists():
│   │                   print(f" [!] Saga for project {project.id} is already in progress. Skipping initiation.")
│   │                   return
│   │           
│   │               print(f"   -> Initiating deletion saga for project: {project.id}")
│   │               try:
│   │                   with transaction.atomic():
│   │                       project.status = ProjectStatus.PENDING_DELETION
│   │                       project.save(update_fields=['status'])
│   │           
│   │                       saga = Saga.objects.create(saga_type='project_deletion', related_resource_id=project.id)
│   │                       services_to_confirm = ['NodeService']
│   │                       for service_name in services_to_confirm:
│   │                           SagaStep.objects.create(saga=saga, service_name=service_name)
│   │                       
│   │                       event_publisher.publish_project_deletion_initiated(project.id, project.owner_id)
│   │                       print(f"   [✓] Successfully initiated saga for project: {project.id}")
│   │           
│   │               except Exception as e:
│   │                   print(f" [!] CRITICAL ERROR: Failed to initiate saga for project {project.id}. Error: {e}")
│   │           
│   │           class Command(BaseCommand):
│   │               help = 'Listens for user deletion events to kick off project deletions.'
│   │           
│   │               def handle(self, *args, **options):
│   │                   while True:
│   │                       try:
│   │                           connection = pika.BlockingConnection(pika.URLParameters(settings.RABBITMQ_URL))
│   │                           channel = connection.channel()
│   │                           
│   │                           channel.exchange_declare(exchange='user_events', exchange_type='topic', durable=True)
│   │                           
│   │                           queue_name = 'project_user_cleanup_initiator_queue'
│   │                           channel.queue_declare(queue=queue_name, durable=True)
│   │                           
│   │                           channel.queue_bind(exchange='user_events', queue=queue_name, routing_key='user.deletion.initiated')
│   │                           
│   │                           self.stdout.write(self.style.SUCCESS(' [*] Project Service user cleanup initiator is waiting for messages.'))
│   │                           
│   │                           channel.basic_consume(queue=queue_name, on_message_callback=self.callback)
│   │                           channel.start_consuming()
│   │           
│   │                       except pika.exceptions.AMQPConnectionError as e:
│   │                           self.stderr.write(self.style.ERROR(f"Connection error: {e}. Retrying in 5s."))
│   │                           time.sleep(5)
│   │                       except KeyboardInterrupt:
│   │                           self.stdout.write(self.style.WARNING("Worker stopped."))
│   │                           break
│   │           
│   │               def callback(self, ch, method, properties, body):
│   │                   try:
│   │                       data = json.loads(body)
│   │                       user_id = data.get('user_id')
│   │                       self.stdout.write(f" [x] Received user.deletion.initiated event for user: {user_id}")
│   │                       
│   │                       if not user_id:
│   │                           self.stderr.write(" [!] Message lacks user_id. Discarding.")
│   │                           ch.basic_ack(delivery_tag=method.delivery_tag)
│   │                           return
│   │           
│   │                       projects_to_delete = Project.objects.filter(owner_id=user_id, status=ProjectStatus.ACTIVE)
│   │                       
│   │                       if projects_to_delete.exists():
│   │                           self.stdout.write(f" [!] Found {projects_to_delete.count()} project(s) to delete for user {user_id}.")
│   │                           for project in projects_to_delete:
│   │                               initiate_single_project_deletion_saga(project)
│   │                       else:
│   │                            self.stdout.write(f" [!] No active projects found for user {user_id}.")
│   │                       
│   │                       # --------------------------------------------------------------------
│   │                       # >>>>>>>>>>>> THE CRITICAL FIX IS HERE <<<<<<<<<<<<<<<
│   │                       # --------------------------------------------------------------------
│   │                       # After handling all projects for the user (either by starting their
│   │                       # deletion sagas or by finding none), we MUST publish the confirmation
│   │                       # event that the Auth Service is waiting for.
│   │                       self.stdout.write(f" [✓] Finished processing all projects for user {user_id}. Publishing confirmation.")
│   │                       event_publisher.publish_all_projects_for_user_deleted(user_id)
│   │                       # --------------------------------------------------------------------
│   │           
│   │                   except Exception as e:
│   │                       self.stderr.write(self.style.ERROR(f" [!] Worker callback crashed: {e}"))
│   │                   
│   │                   ch.basic_ack(delivery_tag=method.delivery_tag)
│   │       ]
│   models.py
│   [
│       import uuid
│       from django.db import models
│       
│       
│       class Saga(models.Model):
│           """Tracks the state of a distributed saga."""
│           class SagaStatus(models.TextChoices):
│               IN_PROGRESS = 'in_progress', 'In Progress'
│               COMPLETED = 'completed', 'Completed'
│               FAILED = 'failed', 'Failed'
│       
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           saga_type = models.CharField(max_length=100, db_index=True) # e.g., 'project_deletion'
│           related_resource_id = models.UUIDField(db_index=True) # The ID of the project being deleted
│           status = models.CharField(max_length=50, choices=SagaStatus.choices, default=SagaStatus.IN_PROGRESS)
│           created_at = models.DateTimeField(auto_now_add=True)
│           updated_at = models.DateTimeField(auto_now=True)
│       
│           def __str__(self):
│               return f"Saga {self.id} ({self.saga_type}) for {self.related_resource_id}"
│       
│       class SagaStep(models.Model):
│           """Tracks the individual confirmation steps for a given saga."""
│           class StepStatus(models.TextChoices):
│               PENDING = 'pending', 'Pending'
│               COMPLETED = 'completed', 'Completed'
│       
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│           saga = models.ForeignKey(Saga, on_delete=models.CASCADE, related_name="steps")
│           service_name = models.CharField(max_length=100) # e.g., 'NodeService', 'AIModelService'
│           status = models.CharField(max_length=50, choices=StepStatus.choices, default=StepStatus.PENDING)
│           updated_at = models.DateTimeField(auto_now=True)
│       
│           class Meta:
│               unique_together = ('saga', 'service_name')
│       
│           def __str__(self):
│               return f"Step {self.service_name} for Saga {self.saga.id} - {self.status}"
│   ]
│   rabbitmq_client.py
│   [
│       # project service/messaging/rabbitmq_client.py
│       
│       import pika
│       import json
│       import time
│       from django.conf import settings
│       import threading
│       
│       class RabbitMQClient:
│           """
│           A thread-safe RabbitMQ client that ensures one connection per thread.
│           This prevents connection sharing issues between the main web server thread
│           and background worker threads.
│           """
│           _thread_local = threading.local()
│       
│           def _get_connection(self):
│               """Gets or creates a connection for the current thread."""
│               if not hasattr(self._thread_local, 'connection') or self._thread_local.connection.is_closed:
│                   print(f"Thread {threading.get_ident()}: No active connection. Connecting to RabbitMQ...")
│                   try:
│                       params = pika.URLParameters(settings.RABBITMQ_URL) # In prod, use settings.RABBITMQ_URL
│                       self._thread_local.connection = pika.BlockingConnection(params)
│                       print(f"Thread {threading.get_ident()}: Connection successful.")
│                   except pika.exceptions.AMQPConnectionError as e:
│                       print(f"CRITICAL: Failed to connect to RabbitMQ: {e}")
│                       # In a real app, this should raise an exception or have a retry mechanism.
│                       raise
│               return self._thread_local.connection
│       
│           def publish(self, exchange_name, routing_key, body):
│               """Publishes a message, ensuring a valid connection and channel."""
│               try:
│                   connection = self._get_connection()
│                   channel = connection.channel()
│                   
│                   # Declare exchanges to ensure they exist. This is idempotent.
│                   channel.exchange_declare(exchange=exchange_name, exchange_type='topic', durable=True)
│       
│                   message_body = json.dumps(body, default=str)
│                   
│                   channel.basic_publish(
│                       exchange=exchange_name,
│                       routing_key=routing_key,
│                       body=message_body,
│                       properties=pika.BasicProperties(
│                           content_type='application/json',
│                           delivery_mode=pika.DeliveryMode.Persistent,
│                       )
│                   )
│                   print(f" [x] Sent '{routing_key}':'{message_body}'")
│               except pika.exceptions.AMQPError as e:
│                   print(f"Error publishing message: {e}. Connection may be closed. It will be reopened on next call.")
│                   # Invalidate the connection so it's recreated on the next call
│                   if hasattr(self._thread_local, 'connection'):
│                       self._thread_local.connection.close()
│                   raise # Re-raise the exception so the caller knows the publish failed
│       
│       # Create a single, globally accessible instance.
│       # The instance itself is shared, but the connection it manages is thread-local.
│       rabbitmq_client = RabbitMQClient()
│   ]
│   tests.py
│   [
│       from django.test import TestCase
│       
│       # Create your tests here.
│       
│   ]
│   views.py
│   [
│       from django.shortcuts import render
│       
│       # Create your views here.
│       
│   ]
├───project
│   __init__.py
│   [
│       
│   ]
│   admin.py
│   [
│       from django.contrib import admin
│       from .models import Project
│       # Register your models here.
│       admin.site.register(Project)
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class ProjectConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'project'
│       
│   ]
│   custom_auth.py
│   [
│       # MS2/products/custom_auth.py
│       from rest_framework_simplejwt.authentication import JWTAuthentication
│       from rest_framework_simplejwt.models import TokenUser # Import TokenUser
│       from rest_framework_simplejwt.settings import api_settings as simple_jwt_settings
│       from django.utils.translation import gettext_lazy as _
│       from rest_framework_simplejwt.exceptions import InvalidToken
│       
│       class ForceTokenUserJWTAuthentication(JWTAuthentication):
│           def get_user(self, validated_token):
│               """
│               Returns a TokenUser instance based on the validated token.
│               Bypasses any local database User lookup for JWT authentication.
│               """
│               try:
│                   # simple_jwt_settings.USER_ID_CLAIM refers to what you set in settings.py
│                   # e.g., "user_id"
│                   user_id = validated_token[simple_jwt_settings.USER_ID_CLAIM]
│               except KeyError:
│                   raise InvalidToken(_("Token contained no recognizable user identification"))
│       
│               # Correct way to instantiate TokenUser: pass the validated_token
│               # The TokenUser class will internally use USER_ID_CLAIM and USER_ID_FIELD
│               # from your SIMPLE_JWT settings to extract the user ID and set its 'id' or 'pk'.
│               token_user = TokenUser(validated_token)
│       
│               # The TokenUser's 'id' (and 'pk') attribute should now be populated correctly
│               # by its own __init__ method based on the validated_token and your SIMPLE_JWT settings
│               # for USER_ID_CLAIM and USER_ID_FIELD.
│       
│               # Example: If you wanted to verify or access it (not strictly necessary here)
│               # print(f"TokenUser ID: {token_user.id}, TokenUser PK: {token_user.pk}")
│       
│               return token_user
│   ]
│   models.py
│   [
│       from django.db import models
│       import uuid
│       
│       
│       class ProjectStatus(models.TextChoices):
│           ACTIVE = 'active', 'Active'
│           PENDING_DELETION = 'pending_deletion', 'Pending Deletion'
│       
│       # Create your models here.
│       class Project(models.Model):
│       
│       
│           id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
│       
│           # <<< ADD THIS FIELD
│           status = models.CharField(
│               max_length=20,
│               choices=ProjectStatus.choices,
│               default=ProjectStatus.ACTIVE,
│               db_index=True,
│               help_text="The current status of the project (e.g., active, pending deletion)."
│           )
│       
│           name = models.CharField(
│               max_length=255,
│               blank=False,
│               null=False,
│               help_text="The user-defined name of the project."
│           )
│           
│       
│           owner_id = models.UUIDField(
│               db_index=True,
│               help_text="The UUID of the user who owns this project. Corresponds to the User ID in the Auth service."
│           )
│       
│       
│           created_at = models.DateTimeField(
│               auto_now_add=True,
│               editable=False,
│               help_text="Timestamp when the project was created."
│           )
│           
│           updated_at = models.DateTimeField(
│               auto_now=True,
│               help_text="Timestamp when the project was last updated."
│           )
│       
│       
│           metadata = models.JSONField(
│               default=dict,
│               blank=True,
│               help_text="Optional flexible metadata for the project (e.g., labels, settings)."
│           )
│       
│           class Meta:
│       
│               ordering = ['-created_at']
│               
│               verbose_name = "Project"
│               verbose_name_plural = "Projects"
│       
│           def __str__(self):
│               """
│               Provides a human-readable representation of the object, which is
│               useful in the Django admin site and for debugging.
│               """
│               return f"{self.name} (ID: {self.id})"
│   ]
│   permissions.py
│   [
│       from rest_framework import permissions
│       
│       class IsOwner(permissions.BasePermission):
│           """
│           Custom permission to only allow owners of an object to perform actions on it.
│           """
│       
│           def has_object_permission(self, request, view, obj):
│               """
│               Return `True` if permission is granted, `False` otherwise.
│               """
│               # The 'obj' is the Project instance that the view is trying to access.
│               # We check if the 'owner_id' stored on the project object matches
│               # the 'id' of the user making the request.
│       
│               # --- THE FIX IS HERE ---
│               # We explicitly convert both IDs to strings before comparing them.
│               # This is the most robust method as it avoids any potential type
│               # mismatches between a UUID object and its string representation.
│               if obj.owner_id and request.user and request.user.is_authenticated:
│                   return str(obj.owner_id) == str(request.user.id)
│                   
│               return False
│   ]
│   serializers.py
│   [
│       # in projects/serializers.py
│       
│       from rest_framework import serializers
│       from .models import Project
│       
│       class ProjectSerializer(serializers.ModelSerializer):
│           """
│           Serializer for the Project model.
│           Handles serialization for list and detail views.
│           """
│           
│           # We make owner_id read-only because it should be set automatically
│           # based on the authenticated user making the request, not from user input.
│           owner_id = serializers.UUIDField(read_only=True)
│       
│           class Meta:
│               model = Project
│               # The fields list remains the same, but the field types are now consistent.
│               fields = ['id', 'name', 'owner_id', 'created_at', 'updated_at', 'metadata']
│               read_only_fields = ['id', 'owner_id', 'created_at', 'updated_at']
│       
│       class ProjectCreateSerializer(serializers.ModelSerializer):
│           """
│           A more constrained serializer specifically for creating projects.
│           This serializer does not need to be changed, as it doesn't include the owner_id field.
│           """
│           class Meta:
│               model = Project
│               fields = ['name', 'metadata']
│               extra_kwargs = {
│                   'metadata': {'required': False}
│               }
│   ]
│   tests.py
│   [
│       from django.test import TestCase
│       
│       # Create your tests here.
│       
│   ]
│   urls.py
│   [
│       # in projects/urls.py
│       
│       from django.urls import path
│       from .views import ProjectListCreateAPIView, ProjectDetailAPIView
│       
│       # The app_name helps in namespacing URLs, which is a good practice.
│       app_name = 'projects'
│       
│       urlpatterns = [
│           # Corresponds to: /ms2/api/v1/project/projects/
│           path('projects/', ProjectListCreateAPIView.as_view(), name='project-list-create'),
│           
│           # Corresponds to: /ms2/api/v1/project/projects/<uuid:pk>/
│           # The <uuid:pk> path converter ensures that only valid UUIDs are accepted.
│           path('projects/<uuid:pk>/', ProjectDetailAPIView.as_view(), name='project-detail'),
│       ]
│   ]
│   views.py
│   [
│       from rest_framework import generics, permissions, status
│       from rest_framework.response import Response
│       
│       from .models import Project
│       from .serializers import ProjectSerializer, ProjectCreateSerializer
│       from .permissions import IsOwner
│       
│       # sage related and messages stuff
│       from messaging.event_publisher import event_publisher
│       from messaging.models import Saga, SagaStep
│       
│       class ProjectListCreateAPIView(generics.ListCreateAPIView):
│           """
│           API view to retrieve a list of projects or create a new project.
│           * GET: Returns a list of projects owned by the authenticated user.
│           * POST: Creates a new project owned by the authenticated user.
│           """
│           permission_classes = [permissions.IsAuthenticated]
│           
│           def get_serializer_class(self):
│               # This remains the same. It correctly selects the serializer
│               # for validating the *input* data on a POST.
│               if self.request.method == 'POST':
│                   return ProjectCreateSerializer
│               return ProjectSerializer
│       
│           def get_queryset(self):
│               """
│               This view should return a list of all the projects
│               for the currently authenticated user.
│               """
│               user = self.request.user
│               return Project.objects.filter(owner_id=user.id)
│       
│           # We are replacing perform_create with a full override of the create method.
│           def create(self, request, *args, **kwargs):
│               """
│               Custom create method to use different serializers for input and output.
│               """
│               # 1. Use the "Create" serializer to validate the incoming request data.
│               write_serializer = self.get_serializer(data=request.data)
│               write_serializer.is_valid(raise_exception=True)
│               
│               # 2. Call our custom perform_create logic to save the object.
│               # This is where we inject the owner_id.
│               instance = self.perform_create(write_serializer)
│               
│               # 3. Use the more detailed "ProjectSerializer" to create the response data.
│               read_serializer = ProjectSerializer(instance)
│               
│               # 4. Manually construct the 201 Created response.
│               headers = self.get_success_headers(read_serializer.data)
│               return Response(read_serializer.data, status=status.HTTP_201_CREATED, headers=headers)
│       
│           def perform_create(self, serializer):
│               """
│               Saves the new instance with the owner_id.
│               This method now returns the created instance so the `create` method can use it.
│               """
│               # The serializer is already validated at this point.
│               return serializer.save(owner_id=self.request.user.id)
│       
│       
│       class ProjectDetailAPIView(generics.RetrieveUpdateDestroyAPIView):
│           
│           # This view remains unchanged, it is already correct.
│           permission_classes = [permissions.IsAuthenticated, IsOwner]
│           serializer_class = ProjectSerializer
│           queryset = Project.objects.all()
│       
│           def destroy(self, request, *args, **kwargs):
│               """
│               Overrides the default delete behavior to initiate a deletion saga
│               instead of deleting the project directly.
│               """
│               # self.get_object() is a DRF helper that retrieves the instance based on the URL's pk.
│               # It also automatically runs our `IsOwner` permission check.
│               # If the user is not the owner, it will raise a 403 Forbidden error before our code runs.
│               project = self.get_object() 
│       
│               # --- NEW SAGA INITIATION LOGIC ---
│       
│               # 1. Idempotency Check: Prevent starting a new saga if one is already running.
│               if Saga.objects.filter(related_resource_id=project.id, status=Saga.SagaStatus.IN_PROGRESS).exists():
│                   return Response(
│                       {"detail": "A deletion process for this project is already in progress."},
│                       status=status.HTTP_409_CONFLICT
│                   )
│       
│               # 2. Soft Delete: Mark the project's status to prevent further use.
│               # This is a critical safety step.
│               project.status = 'pending_deletion'
│               project.save()
│       
│               # 3. Create Saga State: Record the start of this distributed transaction in our database.
│               saga = Saga.objects.create(
│                   saga_type='project_deletion',
│                   related_resource_id=project.id
│               )
│               
│               # Define which services are expected to confirm their part of the cleanup.
│               # This list defines the scope of this saga.
│               services_to_confirm = ['NodeService', 'MemoryService'] # Add 'MemoryService', etc. later
│               for service_name in services_to_confirm:
│                   SagaStep.objects.create(saga=saga, service_name=service_name)
│               
│               # 4. Publish Event: Tell the rest of the system to start working.
│               try:
│                   event_publisher.publish_project_deletion_initiated(
│                       project_id=project.id,
│                       owner_id=project.owner_id
│                   )
│               except Exception as e:
│                   # If we can't even publish the event, the saga cannot start.
│                   # We must roll back our local state changes and inform the user.
│                   project.status = 'active' # Revert the status
│                   project.save()
│                   saga.status = Saga.SagaStatus.FAILED # Mark the saga as failed immediately
│                   saga.save()
│                   
│                   # Log the actual error `e` for debugging.
│                   print(f"ERROR: Failed to publish project.deletion.initiated event: {e}")
│                   
│                   return Response(
│                       {"error": "The deletion process could not be started due to a messaging system error. Please try again later."},
│                       status=status.HTTP_500_INTERNAL_SERVER_ERROR
│                   )
│       
│               # 5. Success Response: Inform the user that the process has begun.
│               return Response(
│                   {"message": "Project deletion process has been successfully initiated."},
│                   status=status.HTTP_202_ACCEPTED
│               )
│   ]
│   project meta gen.py
│   [
│       import os
│       import mimetypes
│       import glob
│       import re
│       
│       def get_next_sequence_number():
│           """Find the next available sequence number for the output file."""
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           pattern = os.path.join(script_dir, "project_structure_*.txt")
│           existing_files = glob.glob(pattern)
│           
│           if not existing_files:
│               return 1
│           
│           # Extract sequence numbers from existing files
│           sequence_numbers = []
│           for file_path in existing_files:
│               basename = os.path.basename(file_path)
│               match = re.search(r'project_structure_(\d+)\.txt', basename)
│               if match:
│                   sequence_numbers.append(int(match.group(1)))
│           
│           if not sequence_numbers:
│               return 1
│           
│           # Return the next number in sequence
│           return max(sequence_numbers) + 1
│       
│       def generate_project_structure():
│           """Generate a text file containing the project structure with file contents."""
│           # Get the absolute path of the script's directory
│           script_dir = os.path.abspath(os.path.dirname(__file__))
│           # Change to that directory to ensure we're working only there
│           os.chdir(script_dir)
│           
│           # Generate a unique filename with sequence number
│           seq_num = get_next_sequence_number()
│           output_file = os.path.join(script_dir, f"project_structure_{seq_num}.txt")
│           
│           with open(output_file, 'w', encoding='utf-8', errors='replace') as f:
│               # Get items in the script directory only, excluding specified patterns
│               items = get_directory_items(script_dir, output_file)
│               
│               # Process each item at root level
│               for i, item in enumerate(items):
│                   is_last = i == len(items) - 1
│                   
│                   if os.path.isdir(os.path.join(script_dir, item)):
│                       # It's a directory
│                       if is_last:
│                           f.write(f"└───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "    ", output_file, script_dir)
│                       else:
│                           f.write(f"├───{item}\n")
│                           process_directory(os.path.join(script_dir, item), f, "│   ", output_file, script_dir)
│                   else:
│                       # It's a file - at root level, format as in the example
│                       f.write(f"│   {item}\n")
│                       # Include file content
│                       content = read_file_content(os.path.join(script_dir, item))
│                       f.write(f"│   [\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           f.write(f"│       {line}\n")
│                       f.write(f"│   ]\n")
│           
│           print(f"Project structure has been written to {output_file}")
│       
│       def should_exclude(item_path):
│           """Check if an item should be excluded based on patterns."""
│           # Exclude __pycache__ directories
│           if os.path.isdir(item_path) and "__pycache__" in item_path:
│               return True
│           
│           # Exclude migrations directories
│           if os.path.isdir(item_path) and "migrations" in item_path:
│               return True
│           
│           # Exclude .pyc files
│           if item_path.endswith('.pyc'):
│               return True
│           
│           # Exclude all project_structure files
│           if os.path.basename(item_path).startswith("project_structure_") and item_path.endswith(".txt"):
│               return True
│           
│           return False
│       
│       def get_directory_items(dir_path, output_file):
│           """Get sorted list of items in a directory, excluding the output file and specified patterns."""
│           # Get absolute path to output file to exclude it
│           abs_output_path = os.path.abspath(output_file)
│           
│           try:
│               # List directory contents
│               items = sorted(os.listdir(dir_path))
│               
│               # Filter out the output file itself and items matching exclude patterns
│               filtered_items = []
│               for item in items:
│                   item_path = os.path.join(dir_path, item)
│                   
│                   # Skip the output file
│                   if os.path.abspath(item_path) == abs_output_path:
│                       continue
│                       
│                   # Skip symlinks that might point outside
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   # Skip items matching exclude patterns
│                   if should_exclude(item_path):
│                       continue
│                       
│                   filtered_items.append(item)
│               
│               return filtered_items
│           except Exception as e:
│               print(f"Error listing directory {dir_path}: {e}")
│               return []
│       
│       def is_binary_file(file_path):
│           """Determine if a file is binary or text."""
│           # Initialize mimetypes
│           if not mimetypes.inited:
│               mimetypes.init()
│           
│           # Check by mime type first
│           mime_type, _ = mimetypes.guess_type(file_path)
│           if mime_type and not mime_type.startswith(('text/', 'application/json', 'application/xml', 'application/javascript')):
│               return True
│               
│           # Fallback: check for null bytes
│           try:
│               with open(file_path, 'rb') as f:
│                   chunk = f.read(4096)
│                   return b'\0' in chunk
│           except Exception:
│               return True  # If we can't read it, assume binary
│       
│       def read_file_content(file_path, max_length=500000):
│           """Read content from a file, handling binary files and errors."""
│           try:
│               # Check if binary
│               if is_binary_file(file_path):
│                   return "[Binary file - content not shown]"
│                   
│               # Read text file
│               with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
│                   content = f.read(max_length + 1)
│                   
│               # Handle truncation
│               if len(content) > max_length:
│                   content = content[:max_length] + "... [truncated]"
│                   
│               # Return raw content without escaping special characters
│               return content
│           except Exception as e:
│               return f"[Error reading file: {str(e)}]"
│       
│       def process_directory(dir_path, file_obj, indent, output_file, script_dir):
│           """Recursively process a directory and write its structure to the file."""
│           # Safety check - ensure we're still within the script directory
│           rel_path = os.path.relpath(dir_path, script_dir)
│           if rel_path.startswith('..') or rel_path == '.':
│               return  # Don't process if it's outside our script directory
│           
│           try:
│               # List directory contents
│               items = get_directory_items(dir_path, output_file)
│               
│               # Process each item
│               for i, item in enumerate(items):
│                   item_path = os.path.join(dir_path, item)
│                   is_last = i == len(items) - 1
│                   
│                   # Safety check - don't follow symlinks or items outside our script directory
│                   if os.path.islink(item_path):
│                       continue
│                       
│                   rel_path = os.path.relpath(item_path, script_dir)
│                   if rel_path.startswith('..'):
│                       continue
│                   
│                   if os.path.isdir(item_path):
│                       # It's a directory
│                       if is_last:
│                           file_obj.write(f"{indent}└───{item}\n")
│                           process_directory(item_path, file_obj, indent + "    ", output_file, script_dir)
│                       else:
│                           file_obj.write(f"{indent}├───{item}\n")
│                           process_directory(item_path, file_obj, indent + "│   ", output_file, script_dir)
│                   else:
│                       # It's a file
│                       file_obj.write(f"{indent}{item}\n")
│                       # Include file content
│                       content = read_file_content(item_path)
│                       file_obj.write(f"{indent}[\n")
│                       content_lines = content.split('\n')
│                       for line in content_lines:
│                           file_obj.write(f"{indent}    {line}\n")
│                       file_obj.write(f"{indent}]\n")
│           except PermissionError:
│               file_obj.write(f"{indent}[Permission denied]\n")
│           except Exception as e:
│               file_obj.write(f"{indent}[Error: {str(e)}]\n")
│       
│       if __name__ == "__main__":
│           generate_project_structure()
│   ]
├───projectsinternal
│   __init__.py
│   [
│       
│   ]
│   apps.py
│   [
│       from django.apps import AppConfig
│       
│       
│       class ProjectsinternalConfig(AppConfig):
│           default_auto_field = 'django.db.models.BigAutoField'
│           name = 'projectsinternal'
│       
│   ]
│   internal_urls.py
│   [
│       
│       
│       from django.urls import path
│       from .internal_views import ProjectAuthorizationView
│       # The app_name helps in namespacing URLs, which is a good practice.
│       app_name = 'projectsinternal'
│       
│       urlpatterns = [
│       
│           # The path matches what our NodeService's client expects.
│           path('projects/<uuid:project_id>/authorize', ProjectAuthorizationView.as_view(), name='internal-project-authorize'),
│       
│       ]
│       
│   ]
│   internal_views.py
│   [
│       from rest_framework.views import APIView
│       from rest_framework.response import Response
│       from rest_framework import status, permissions
│       from project.models import Project
│       
│       
│       class ProjectAuthorizationView(APIView):
│           """
│           Internal-only view to check if a user is the owner of a project.
│           It expects the JWT of the original user to be forwarded in the Authorization header.
│           """
│           # This view is still protected by authentication. It verifies the forwarded JWT.
│           permission_classes = [permissions.IsAuthenticated]
│       
│           def get(self, request, project_id):
│               """
│               Checks ownership. Returns 204 on success, 403/404 on failure.
│               """
│               try:
│                   # We only need to check for existence and ownership.
│                   # We can do this with a single, efficient query.
│                   is_owner = Project.objects.filter(
│                       id=project_id, 
│                       owner_id=request.user.id
│                   ).exists()
│       
│                   if is_owner:
│                       # 204 No Content is a lightweight, fast success response.
│                       # It signals "Yes, authorized" without needing a body.
│                       return Response(status=status.HTTP_204_NO_CONTENT)
│                   else:
│                       # We need to distinguish between "project exists but you don't own it"
│                       # and "project doesn't exist at all".
│                       if Project.objects.filter(id=project_id).exists():
│                           # The project exists, but the owner_id doesn't match.
│                           return Response({"detail": "Permission denied."}, status=status.HTTP_403_FORBIDDEN)
│                       else:
│                           # The project itself was not found.
│                           return Response({"detail": "Project not found."}, status=status.HTTP_404_NOT_FOUND)
│       
│               except Exception:
│                   # Catch any unexpected errors (e.g., invalid UUID format).
│                   return Response({"detail": "Bad Request."}, status=status.HTTP_400_BAD_REQUEST)
│   ]
│   requirements.txt
│   [
│       asgiref==3.9.1
│       certifi==2025.7.14
│       cffi==1.17.1
│       charset-normalizer==3.4.2
│       cryptography==45.0.5
│       defusedxml==0.7.1
│       Django==5.2.4
│       djangorestframework==3.16.0
│       djangorestframework_simplejwt==5.5.1
│       djoser==2.3.3
│       idna==3.10
│       oauthlib==3.3.1
│       pycparser==2.22
│       PyJWT==2.10.1
│       python3-openid==3.2.0
│       requests==2.32.4
│       requests-oauthlib==2.0.0
│       social-auth-app-django==5.5.1
│       social-auth-core==4.7.0
│       sqlparse==0.5.3
│       tzdata==2025.2
│       urllib3==2.5.0
│       dotenv
│       pika
│   ]
